####################################################################
# NEVER CHANGE THIS FILE
#
# Definitions of register values and partial register values.
#
# If Firmware changes generate a new definition file specifying
# the firmware version in the name.
#
# Setting AccesMode can take 3 values 0 = Read/Write, 1 = Read Only ,2 = Write Only (no response), 3 = Read/Non sticky write;
####################################################################
HEADER
TM_TYPE TM_5
TM_FIRMWARE_VERSION 0xFEDA003D
DESCRIPTION This is firmware version 0xFEDA003D, which is the up-to-date version for CHEC-M camera modules as of Aug 21, 2015.
RESPONSIBLE_AUTHOR Akira Okumura (refined by Rich)
NUM_REGISTERS 0x54
##############################################################################################
# Setting layout: All fields must be filled, use 0 for default value.
#
# Field: Name           RegAddr nBits   startBit value    AccessMode    lowerBound upperBound multiplier offset description
# Type:  string         uint8_t uint8_t uint8_t  uint32_t enum(0,1,2,3) uint32_t   uint32_t   float      float  strings
##############################################################################################
SETTINGS
FirmwareVersion         0x00    32      0        0xFEDA003D      1          0x0        0xFFFFFFFF        0.         0.     Assigned value of 0xFED00003D, assigned in Firmware to highlight and track incremental changes in firmware. Incremented with every firmware revision
AnyValue                0x01    16      16       0x0      0          0x0        0xFFFF     0.         0.     Any value for control software, does not have effect on any FPGA logic
ModuleIndex             0x01    8       8        0x0      0          0x0        0xFF       0.         0.    Sequential number for this module - used in event building (was Detector ID), written in to the raw data
ModuleSlot              0x01    8       0        0x0      0          0x0        0xFF       0.         0.     Slot number for this module - used in data analysis (was CTAID), written in to the raw data
SerialNumLSW            0x02    32      0        0x0      1          0x0        0xFFFFFFF  0.         0.     Serial number the least significant word
SerialNumMSW            0x03    32      0        0x0      1          0x0        0xFFFFFFF  0.         0.     Serial number the most significant word
# Status register
Unused_0x04_0           0x04    16      16       0x0      1          0x0        0x0        0.         0.     Unused bits
BackPlaneStatus         0x04    4       12       0x0      1          0x0        0x0        0.         0.     Status of backplane lines from bp4 to bp7 (also, bp5 is reset and will not be available due to board reset)
Unused_0x04_1           0x04    1       11       0x0      1          0x0        0x0        0.         0.     Unused bits
mgt_AVCC_OK             0x04    1       10       0x0      1          0x0        0x0        0.         0.     mgt_AVCC_OK is OK, 1- OK, 0 - is not
+1.8V_OK                0x04    1       9        0x0      1          0x0        0x0        0.         0.     +1.8 V is OK, 1-OK, 0-is not
Unused_0x04_2           0x04    7       2        0x0      1          0x0        0x0        0.         0.     Unused bit
FIFOUnderflow           0x04    1       1        0x0      1          0x0        0x0        0.         0.     Underflow on summary FIFO of event data
FIFOOverflow            0x04    1       0        0x0      1          0x0        0x0        0.         0.     Overflow on summary FIFO of event data
# Latched status register
Unused_0x05_0		0x05    16      16       0x0      1          0x0        0x0        0.         0.     Unused bits
LatchedBackPlaneStatus  0x05    4       12       0x0      3          0x0        0x1        0.         0.     Status of backplane lines from bp4 to bp7 (also, bp5 is reset and will not be available due to board reset) (Writing one will reset corresponding bit)
Unused_0x05_1		0x05    1       11       0x0      1          0x0        0x0        0.         0.     Unused bits
Latchedmgt_AVCC_OK      0x05    1       10       0x0      3          0x0        0x1        0.         0.     mgt_AVCC_OK is OK, 1- OK, 0 - is not (Writing one will reset corresponding bit)
Latched+1.8V_OK         0x05    1       9        0x0      3          0x0        0x1        0.         0.     +1.8 V is OK, 1-OK, 0-is not (Writing one will reset corresponding bit)
Unused_0x05_2		0x05    7       2        0x0      1          0x0        0x0        0.         0.     Unused bit
LatchedFIFOUnderflow    0x05    1       1        0x0      0          0x0        0x1        0.         0.     Underflow on summary FIFO of event data (Writing one will reset corresponding bit)
LatchedFIFOOverflow     0x05    1       0        0x0      0          0x0        0x1        0.         0.     Overflow on summary FIFO of event data (Writing one will reset corresponding bit)
FIFOStatus_0            0x06    32      0        0x0      1          0x0        0x0        0.         0.     Data Storage FIFO underflow(bits 1,3,5,7,..) and overflow (0,2,4,..) errors. Two bits per acquisition channel. Channel 0 errors reported in bits 0(underflow) and 1(overflow), channel 1 in bits 2 and 3,....
LatchedFIFOStatus_0     0x07    32      0        0x0      0          0x0        0x1        0.         0.     Data Storage FIFO underflow(bits 1,3,5,7,..) and overflow (0,2,4,..) errors. Two bits per acquisition channel. Channel 0 errors reported in bits 0(underflow) and 1(overflow), channel 1 in bits 2 and 3,.... (Writing one will reset corresponding bit)
FIFOStatus_1            0x08    32      0        0x0      1          0x0        0x0        0.         0.     Data Storage FIFO underflow(bits 1,3,5,7,..) and overflow (0,2,4,..) errors. Two bits per acquisition channel. Channel 0 errors reported in bits 0(underflow) and 1(overflow), channel 1 in bits 2 and 3,....
LatchedFIFOStatus_1     0x09    32      0        0x0      0          0x0        0x1        0.         0.     Data Storage FIFO underflow(bits 1,3,5,7,..) and overflow (0,2,4,..) errors. Two bits per acquisition channel. Channel 0 errors reported in bits 0(underflow) and 1(overflow), channel 1 in bits 2 and 3,.... (Writing one will reset corresponding bit)
FIFOStatus_2            0x0A    32      0        0x0      1          0x0        0x0        0.         0.     Data Storage FIFO underflow(bits 1,3,5,7,..) and overflow (0,2,4,..) errors. Two bits per acquisition channel. Channel 0 errors reported in bits 0(underflow) and 1(overflow), channel 1 in bits 2 and 3,....
LatchedFIFOStatus_2     0x0B    32      0        0x0      0          0x0        0x1        0.         0.     Data Storage FIFO underflow(bits 1,3,5,7,..) and overflow (0,2,4,..) errors. Two bits per acquisition channel. Channel 0 errors reported in bits 0(underflow) and 1(overflow), channel 1 in bits 2 and 3,.... (Writing one will reset corresponding bit)
FIFOStatus_3            0x0C    32      0        0x0      1          0x0        0x0        0.         0.     Data Storage FIFO underflow(bits 1,3,5,7,..) and overflow (0,2,4,..) errors. Two bits per acquisition channel. Channel 0 errors reported in bits 0(underflow) and 1(overflow), channel 1 in bits 2 and 3,....
LatchedFIFOStatus_3     0x0D    32      0        0x0      0          0x0        0x1        0.         0.     Data Storage FIFO underflow(bits 1,3,5,7,..) and overflow (0,2,4,..) errors. Two bits per acquisition channel. Channel 0 errors reported in bits 0(underflow) and 1(overflow), channel 1 in bits 2 and 3,.... (Writing one will reset corresponding bit)
TriggerFIFOStatus       0x0E    32      0        0x0      1          0x0        0x0        0.         0.     Free running time counter value set by sync over TACK pass 32 MSB
# Trigger statistics
CountGoodSyncTACKs      0x0F    16      16       0x0      3          0x0        0x1        0.         0.     Count number of good Sync verification TACKs. (Writing any value into this register will reset all counters in registers 0xF, 0x10, 0x11, 0x12 and some on 0x13)
CountTACKsReceived      0x0F    16      0        0x0      3          0x0        0x1        0.         0.     Count number of good Sync verification TACKs. (Writing any value into this register will reset all counters in registers 0xF, 0x10, 0x11, 0x12 and some on 0x13)
# TACK statistics
CountSyncErrors         0x10    8       24       0x0      1          0x0        0x1        0.         0.     Count sync errors. Time sync verification failed. Counter is reset by writing any value into register 0xF
CountTACKRangeErrors    0x10    8       16       0x0      1          0x0        0x1        0.         0.     Count of range error over Tack. Counter is reset by writing any value into register 0xF
CountTACKParityErrors2  0x10    8       8        0x0      1          0x0        0x1        0.         0.     Same as count in bits 7-0. Count Tack Parity errors
CountTACKParityErrors   0x10    8       0        0x0      1          0x0        0x1        0.         0.     Count Tack Parity errors. Counter is reset by writing any value into register 0xF
# FIFO statistics
CountDataPacketsEnabled 0x11    16      16       0x0      1          0x0        0x1        0.         0.     Count all enabled for counting (bits 31 of register 0x17) built packets on all incoming channels. Counter is reset by writing any value into register 0xF
CountDataPackets        0x11    16      0        0x0      1          0x0        0x1        0.         0.     Count all built packets on all incoming channels. Counter is reset by writing any value into register 0xF
# Packet statistics
CountForwardedPackets   0x12    16      16       0x0      1          0x0        0x1        0.         0.     Internal Arbiter Counter, count all packet forwarded from internal storage to MAC. Counter is reset by writing any value into register 0xF
CountTransmittedPackets 0x12    16      0        0x0      1          0x0        0x1        0.         0.     MAC Counter, count all transmitted packet by MAC. Counter is reset by writing any value into register 0xF
# Ramp count statistics
CountCommandPackets     0x13    16      16       0x0      1          0x0        0x1        0.         0.     Count command issued to Camera module. Counter is reset by writing any value into register 0xF
CountProcessedEvents    0x13    16      0        0x0      1          0x0        0x1        0.         0.     Count number of event processed. Counter is reset by writing any value into register 0xF
# ADC mode
Unused_0x14	        0x14    30      2        0x0      0          0x0        0x0        0.         0.     Unused bits
ADC1Mode                0x14    1       1        0x0      0          0x0        0x1        0.         0.     Select ADC mode for T5 module ADC 1( 0 - acquire data continuously after start in reg 0x15, 1 - acquire just once after start in reg 0x15)
ADC0Mode                0x14    1       0        0x0      0          0x0        0x1        0.         0.     Select ADC mode for T5 module ADC 0( 0 - acquire data continuously after start in reg 0x15, 1 - acquire just once after start in reg 0x15)
# ADC configuration
ADC1Start               0x15    1       31       0x1      0          0x0        0x1        0.         0.     ADC 1 logic, Writing one into this bit will start ADC acquisition immediately.
Unused_0x15_0	        0x15    5       26       0x0      1          0x0        0x0        0.         0.     Unused bits
ADC1Averaging           0x15    3       23       0x0      0          0x0        0x7        0.         0.     ADC 1 logic, Select averaging and number of averages<br>http://datasheets.maxim-ic.com/en/ds/MAX1227-MAX1231.pdf<br>0xx - perform one conversion for each result<br>100 - perform four conversions and return average for each result<br>101 - perform eight conversions and return average for each result<br>110 - perform 16 conversions and return average for each result<br>111 - perform 32 conversions and return average for each result
ADC1ChannelSelect       0x15    4       19       0xB      0          0xB        0xB        0.         0.     ADC 1 logic, Channel select bits, Set to b1011 to read all 12 channels<br>http://datasheets.maxim-ic.com/en/ds/MAX1227-MAX1231.pdf<br>Must be set to b1011
Unused_0x15_1           0x15    1       18       0x0      1          0x0        0x0        0.         0.     Unused
ADC1SelectScanMode      0x15    1       17       0x0      1          0x0        0x0        0.         0.     ADC 1 logic, Select scan mode, bit 0 of scan bits<br>http://datasheets.maxim-ic.com/en/ds/MAX1227-MAX1231.pdf<br>0- Select readout of channels from 0 through N, 1- from N to highest numbered channel. Must be set to 0
Unused_0x15_2           0x15    1       16       0x0      1          0x0        0x0        0.         0.     Unused
ADC0Start               0x15    1       15       0x1      0          0x0        0x1        0.         0.     ADC 0 logic, Writing one into this bit will start ADC acquisition immediately.
Unused_0x15_3           0x15    5       10       0x0      1          0x0        0x0        0.         0.     Unused bits
ADC0Averaging           0x15    3       7        0x0      0          0x0        0x7        0.         0.     ADC 0 logic, Select averaging and number of averages<br>http://datasheets.maxim-ic.com/en/ds/MAX1227-MAX1231.pdf<br>0xx - perform one conversion for each result<br>100 - perform four conversions and return average for each result<br>101 - perform eight conversions and return average for each result<br>110 - perform 16 conversions and return average for each result<br>111 - perform 32 conversions and return average for each result
ADC0ChannelSelect       0x15    4       3        0xB      0          0xB        0xB        0.         0.     ADC 0 logic, Channel select bits, Set to b1011 to read all 12 channels<br>http://datasheets.maxim-ic.com/en/ds/MAX1227-MAX1231.pdf<br>Must be set to b1011
Unused_0x15_4           0x15    1       2        0x0      1          0x0        0x0        0.         0.     Unused
ADC0SelectScanMode      0x15    1       1        0x0      1          0x0        0x0        0.         0.     ADC 0 logic, Select scan mode, bit 0 of scan bits<br>http://datasheets.maxim-ic.com/en/ds/MAX1227-MAX1231.pdf<br>0- Select readout of channels from 0 through N, 1- from N to highest numbered channel. Must be set to 0
Unused_0x15_5           0x15    1       0        0x0      1          0x0        0x0        0.         0.     Unused
# Time register
TimeCounter             0x16    32      0        0x0      1          0x0        0x0        0.         0.     Free running time counter value set by sync over TACK pass 32 LSB
# Control register 0
EnablePacketCount       0x17    1       31       0x0      0          0x0        0x1        0.         0.     Enable packet count in register 0x11, bits 31-16
MaxChannelsInPacket     0x17    7       24       0x04     0          0x0        0x40       0.         0.     Maximum Ethernet packet size parameter. Indicate how many channels out of available 64 can be shipped in one packet. Either 0 or 1 indicates one channel per network packet. 2, 3, ...  indicate 2, 3 ... channels per packet.<br>Careful attention need to be taken to set this parameter. First of all user need to know type of network card host system will have and if it support Jumbo packets. In any case maximum size of acceptable network packet need to be compared with expected event size and properly divided into packets. Default value of 0 (or 1) always process just one channel per packet and works in all cases but will generate maximum number of packets (64). This parameter help to reduce number of packets and related overhead for packet header and trailer to optimize system performance.
ASICTestOutputType      0x17    4       20       0x0      0          0x0        0xF        0.         0.     Select output type for ASIC Test output.<br>0x0 - 62.5MHz<br>0x1... - TBD
ASICTestOutputEnable    0x17    1       19       0x0      0          0x0        0x1        0.         0.     Enable Test Output to ASICs channel 15
RampSignalDuration      0x17    11      8        0x37F    0          0x0        0x8FF      0.         0.     Specify ramp signal duration to Target
RampStartDelay          0x17    5       3        0x0      0          0x0        0x1F       0.         0.     Ramp start delay after trigger, in system clocks (8 ns)
QuadrantOffset_Enable   0x17    1       2        0x0      0          0x0        0x1        0.         0.     Offset usage enable (1). In order to optimize 48 samples readout relatively to trigger position, logic implement option to sync readout to 8 sample bins (4 bins per buffer). Setting bit to one will enable this feature. Otherwise buffer readout always start from beginning. Should be noted that that setting number of readout buffer to more then 2( Bits 23-20) will disable offset usage. And for software buffer this feature disabled as well (bit 9 of 0x1b)
Unused_0x17		0x17    1       1        0x1      0          0x0        0x0        0.         0.     Unused
EnableBit		0x17    1       0        0x1      1          0x0        0x1        0.         0.     Enable bit, 1- enable analog sampling, after proper Sync command issued***
# Control register 1
Unused_0x18_0  		0x18    2       30       0x0      0          0x0        0x0        0.         0.     Unused
VdlyNFeedback3          0x18    1       29       0x1      0          0x0        0x1        0.         0.     VdlyN feedback on (1)/off(0) control ASIC 3
VdlyFeedback3           0x18    1       28       0x0      0          0x0        0x1        0.         0.     Vdly feedback on (1)/off(0) control ASIC 3
TST_START3              0x18    1       27       0x0      0          0x0        0x1        0.         0.     Directly control tst_start input to Target ASIC 3, set to 1
TST_BOICLR3             0x18    1       26       0x0      0          0x0        0x1        0.         0.     Directly control tst_boiclr input to Target ASIC 3, set to 0
CLR_REG3                0x18    1       25       0x0      0          0x0        0x1        0.         0.     Directly control clr_reg input to Target ASIC 3
PowerUpASIC3            0x18    1       24       0x0      0          0x0        0x1        0.         0.     Power up ASIC 3 bit. (0 -turn off 2.5V to ASIC, 1 - turn on 2.5V to ASIC)
Unused_0x18_1		0x18    2       22       0x0      0          0x0        0x0        0.         0.     Unused
VdlyNFeedback2          0x18    1       21       0x1      0          0x0        0x1        0.         0.     VdlyN feedback on (1)/off(0) control ASIC 2
VdlyFeedback2           0x18    1       20       0x0      0          0x0        0x1        0.         0.     Vdly feedback on (1)/off(0) control ASIC 2
TST_START2              0x18    1       19       0x0      0          0x0        0x1        0.         0.     Directly control tst_start input to Target ASIC 2, set to 1
TST_BOICLR2             0x18    1       18       0x0      0          0x0        0x1        0.         0.     Directly control tst_boiclr input to Target ASIC 2, set to 0
CLR_REG2                0x18    1       17       0x0      0          0x0        0x1        0.         0.     Directly control clr_reg input to Target ASIC 2
PowerUpASIC2            0x18    1       16       0x0      0          0x0        0x1        0.         0.     Power up ASIC 1 bit. (0 -turn off 2.5V to ASIC, 1 - turn on 2.5V to ASIC)
Unused_0x18_2		0x18    2       14       0x0      0          0x0        0x0        0.         0.     Unused
VdlyNFeedback1          0x18    1       13       0x1      0          0x0        0x1        0.         0.     VdlyN feedback on (1)/off(0) control ASIC 1
VdlyFeedback1           0x18    1       12       0x0      0          0x0        0x1        0.         0.     Vdly feedback on (1)/off(0) control ASIC 1
TST_START1              0x18    1       11       0x0      0          0x0        0x1        0.         0.     Directly control tst_start input to Target ASIC 1, set to 1
TST_BOICLR1             0x18    1       10       0x0      0          0x0        0x1        0.         0.     Directly control tst_boiclr input to Target ASIC 1, set to 0
CLR_REG1                0x18    1       9        0x0      0          0x0        0x1        0.         0.     Directly control clr_reg input to Target ASIC 1
PowerUpASIC1            0x18    1       8        0x0      0          0x0        0x1        0.         0.     Power up ASIC 1 bit. (0 -turn off 2.5V to ASIC, 1 - turn on 2.5V to ASIC)
Unused_0x18_3           0x18    2       6        0x0      0          0x0        0x0        0.         0.     Unused
VdlyNFeedback0          0x18    1       5        0x1      0          0x0        0x1        0.         0.     VdlyN feedback on (1)/off(0) control ASIC 0
VdlyFeedback0           0x18    1       4        0x0      0          0x0        0x1        0.         0.     Vdly feedback on (1)/off(0) control ASIC 0
TST_START0              0x18    1       3        0x0      0          0x0        0x1        0.         0.     Directly control tst_start input to Target ASIC 0, set to 1
TST_BOICLR0             0x18    1       2        0x0      0          0x0        0x1        0.         0.     Directly control tst_boiclr input to Target ASIC 0, set to 0
CLR_REG0                0x18    1       1        0x0      0          0x0        0x1        0.         0.     Directly control clr_reg input to Target ASIC 0
PowerUpASIC0            0x18    1       0        0x0      0          0x0        0x1        0.         0.     Power up ASIC 0 bit. (0 -turn off 2.5V to ASIC, 1 - turn on 2.5V to ASIC)
# Trigger control register 0
TriggerDelay            0x19    14      18       0x0      0          0x0        0x3FFF     0.         0.     Trigger delay, to compensate for time between trigger arrival and trigger decision making, need to be found experimentally. Count in 1ns steps
Unused_0x19		0x19    4       14       0x0      0          0x0        0x0        0.         0.     Unused
TriggerDelayAlternative 0x19    14      0        0x0      0          0x0        0x3FFF     0.         0.     Trigger delay alternative, to compensate for time between trigger arrival and trigger decision making, need to be found experimentally. Count in 1ns steps
# Trigger control register 1
DataSendingDelay        0x1A    13      1        0x0      0          0x0        0x1FFF     0.         0.128  Set the delay in sending a data packet after a TACK is received (calibrated value is in microseconds)
EnableCommsClockFromARP 0x1A    1       14       0x0     0           0x0        0x0        0.         0.      If set to 0: recover phase of comms clock from ARP messages; if set to 1: manually set phase in bit 14 (although 0 is selected, manually setting phase might be required due to buggy implementation)
EventPortNumber         0x1A    16      16       0xFF      0         0x0        0x7FFF     0.         0.     Set the port number for event data to be sent to (implemented for CHEC by LS early 2014)
PhaseOfTACKClock        0x1A    1       0        0x0      0          0x0        0x1        0.         0.     Select phase of clock to sample TACK from BP (0 - rising edge, 1 - falling edge)
PhaseOfCommsClock	      0x1A	  1	      15	       0x0	  0	     0x0	0x1	   0.	      0.     Select the phase of the clock which determines the 8 ns / 16 ns edge for the ethernet responses
# Row/column control/status
LatestRow               0x1B    3       29       0x0      1          0x0        0x0        0.         0.     Latched by latest trigger value of row counter
LatestColumn            0x1B    6       23       0x0      1          0x0        0x0        0.         0.     Latched by latest trigger value of column counter
LatestSample            0x1B    4       19       0x0      1          0x0        0x0        0.         0.     Latched by latest trigger value of sample value (only 4 MSB)
CurrentRow              0x1B    3       16       0x0      1          0x0        0x0        0.         0.     Free running current row value to simulate sampling buffer write row pointer
CurrentColumn           0x1B    6       10       0x0      1          0x0        0x0        0.         0.     Free running current column value to simulate sampling buffer write column pointer
Unused_0x1B	        0x1B    1       9        0x0      0          0x0        0x0        0.         0.     Unused
Column                  0x1B    6       3        0x0      0          0x0        0x3F       0.         0.     Specify column for readout when Software trigger mode selected by TACK command.
Row                     0x1B    3       0        0x0      0          0x0        0x7        0.         0.     Specify row for readout when Software trigger mode selected by TACK command.
# Number of samples to read
UnusedNumberOfSamples0  0x1C    12      20       0x0      0          0x0        0x0        0.         0.     Unused
AltNumberOfBlocks       0x1C    4       16       0x0      0          0x0        0xF        0.         0.     Specify number of alternative buffer for readout, with 0 corresponding to 1 buffers, with 1 - 2 buffers, with 15 - 16 buffers (maximum)
Unused_0x1C		0x1C    7       9        0x0      0          0x0        0x0        0.         0.     Unused
NumSampOnPartBlock      0x1C    5       4        0x10      0          0x0        0x20       0.         0.     Number of samples on partial buffer, from 0 to 31, to enable flexible readout of any number of desirable samples. At the moment value of 1 -> 16 samples, 0 ��� 0 samples. Optimized for 48 sample event
NumberOfBlocks	        0x1C    4       0        0x3      0          0x0        0xF        0.         0.     Specify number of buffer for readout, with 0 corresponding to 1 buffers, with 1 - 2 buffers, with 15 - 16 buffers (maximum)
# Serial data idelay control register
Unused_0x1D		0x1D    32      0        0x0      0          0x0        0x0        0.         0.     Unused
# Configuration waveform register
PCLK_SINhigh            0x1E    8       24       0x6      0          0x0        0xFF       0.         0.     PCLK width plus 1 when SIN high, need to be set to 0x3
SIN_afterPCLK           0x1E    8       16       0x3      0          0x0        0xFF       0.         0.     SIN settling time after PCLK plus 1, need to set to 1
SIN_beforePCLK          0x1E    8       8        0x3      0          0x0        0xFF       0.         0.     SIN settling time before PCLK plus 1, need to set to 1
PCLK_SINlow             0x1E    8       0        0x10      0         0x0        0xFF       0.         0.     PCLK width plus 1 when SIN low, need to be set to 0x7
# Misc test register
Unused_0x1f_0           0x1F    10      22       0x0      0          0x0        0x0        0.         0.     Unused
SpecialMode             0x1F    2       20       0x0      0          0x0        0x0        0.         0.     Special mode, must be 0
Unused_0x1f_1           0x1F    8       12       0x0      0          0x0        0x0        0.         0.     Unused
SelectSampleClockPhase  0x1F    4       8        0x0      0          0x0        0x0        0.         0.     Select clock phase for input data (0- sampled on falling edge, 1 - sampled on rising edge), 0 ��� looks like right selection. One bit per ASIC. Bit 8 ��� ASIC 0, Bit 9 ��� ASIC 1, ....
Unused_0x1f_2           0x1F    6       2        0x0      0          0x0        0x0        0.         0.     Unused
SR_Sel_Mode             0x1F    1       1        0x0      0          0x0        0x0        0.         0.     Select if SR_SEL pulse signal asserted all time (1) or only actual event readout process
Unused_0x1f_3           0x1F    1       0        0x0      0          0x0        0x0        0.         0.     Unused
# SST FB PLL alignments register
RCOEdge3         0x20    1       31        0x0     1          0x0        0x0        0.         0.     RCO sampled with PLL clock and re-sampled with system clock to find proper edge (low to high), ignore of high to low. ASIC 3
RCOEdge2         0x20    1       30        0x0     1          0x0        0x0        0.         0.     RCO sampled with PLL clock and re-sampled with system clock to find proper edge (low to high), ignore of high to low. ASIC 2
RCOEdge1         0x20    1       29        0x0     1          0x0        0x0        0.         0.     RCO sampled with PLL clock and re-sampled with system clock to find proper edge (low to high), ignore of high to low. ASIC 1
RCOEdge0         0x20    1       28        0x0     1          0x0        0x0        0.         0.     RCO sampled with PLL clock and re-sampled with system clock to find proper edge (low to high), ignore of high to low. ASIC 0
Unused_0x20_0    0x20    3       25        0x0     1          0x0        0x0        0.         0.     Spare
RecPLLDelay      0x20    9       16        0x0     1          0x0        0x0        0.         0.     Value recorded into PLL delay (previous value)
Unused_0x20_1    0x20    5       11        0x0     1          0x0        0x0        0.         0.     Spare
SSTsetup         0x20    2        9        0x0     0          0x0        0x4        0.         0.     Select ASIC to address SST setup : 00 - ASIC0, 01 ��� ASIC1, 10 ��� ASIC2, 11 ��� ASIC3
ShiftSampClk     0x20    9        0        0x0     0          0x0        0xFF       0.         0.    PLL setup value to shift sampling clock timing to align with SST input (from Target) for proper SST type feedback control. Actual value range is from 0 to 0xFF. Each step is about 125ps (estimate)
# SST FB idelay alignments register control 0x21, unused
Unused_0x21      0x21    32       0        0x0      0          0x0        0x0        0.         0.     Unused
# SST FB idelay alignments register status: Address 0x22
Unused_0x22         0x22    32       0        0x0      1          0x0        0x0        0.         0.     Unused
# 0x23, Spare unused
Unused_0x23         0x23    32       0        0x0      0          0x0        0x0        0.         0.     Unused
# ROVDD feedback control ASIC 0
VdlyN_VDD0              0x24    12      20       0x8C6      0          0x0        0xFFF      0.         0.     Set VDD value for ROVDD feedback loop, this value should be as close as possible to final desired sampling frequency. But from practical point only VdlyN control sampling frequency, so we should use only VdlyN to control RCO frequency to adjust sampling. Default value for 1GHz sampling is 0x910, therefore to control VdlyN we need to invert this value to 0x911(TBD) as starting RCO feedback value. Similarly for 400MHz sampling we have 0xBC0, so we have to set feedback initial value to 0xBC1(TBD). VdlyN Feedback enabled by bit 5 of the register 0x18.
VdlyN_Compare0          0x24    20      0        0xA7D0      0          0x0        0xFFFFF    0.         0.     Bit in this field are interpreted on base of the ASIC configuration bit which are stored in reg. 0x2c bit 30. If bit set to 1:Compare value for ROVDD feedback loop. This is actual value which effect RCO final frequency. To find rough value we need to multiply desired RCO period in ns by 256. It is a little tricky task, because RCO runs faster than desired sampling frequency, so we need to target slower value of RCO frequency to get desired frequency. To have 1GHz sampling we need to set RCO roughly to 1GHz/128 = 7.8MHz(or period of 128ns), however in practice real 1GHz sampling achieved at 5.95MHZ (or 168ns) given that VdlyP set to value of 0x680 (to make RCO closer to 50% duty cycle). In this case value of this register need to be set 168*256=43008 (or 0xa800). Similarly for 400MHz sampling we need to set this value to about 1.88MHz(531ns) or value of 256*531= ~0x212f0 (need to be verified for 400MHz sampling) If bit set to 0:Then this field divided into 2: - bits 19-10 specify computational compare value for feedback control, nominally should be 0x200 - bits 9-0 specify computational compare hysteresis value for feedback control. Value from libchec: 0x1000 - 0x73A
# ROVDD feedback control ASIC 1
VdlyN_VDD1              0x25    12      20       0x8C6      0          0x0        0xFFF      0.         0.     ditto
VdlyN_Compare1          0x25    20      0        0xA7D0      0          0x0        0xFFFFF    0.         0.     ditto
# ROVDD feedback control ASIC 2
VdlyN_VDD2              0x26    12      20       0x8C6      0          0x0        0xFFF      0.         0.     ditto
VdlyN_Compare2          0x26    20      0        0xA7D0      0          0x0        0xFFFFF    0.         0.     ditto
# ROVDD feedback control ASIC 3
VdlyN_VDD3              0x27    12      20       0x8C6      0          0x0        0xFFF      0.         0.     ditto
VdlyN_Compare3          0x27    20      0        0xA7D0      0          0x0        0xFFFFF    0.         0.     ditto
# Vdly feedback control ASIC 0
Vdly_VDD0               0x28    12      20       0x850      0          0x0        0xFFF      0.         0.     Set VDD value for Vdly feedback loop. Need to be set as close as possible to desired Wilkinson sampling control voltage DAC value. It is roughly 0x900. Vdly Feedback enabled by bit 4 of the register 0x18.
Vdly_Compare0           0x28    20      0        0x16db6      0          0x0        0xFFFFF    0.         0.     Compare value for Vdly feedback loop. This is value which effect final Vdly and related Wilkinson sampling frequency. It is computed by multiplying Wilkinson sampling period by 65536 (2^16). So, for example, for 700Mhz sampling we have period of 1.42ns. 1.42*65536 = 93623(16DB6). Also in practical sense we can measure frequency of Vdly*4096 on output pin. So to set this value we need just multiply desired observed period by 16.
# Vdly feedback control ASIC 1
Vdly_VDD1               0x29    12      20       0x850      0          0x0        0xFFF      0.         0.     ditto
Vdly_Compare1           0x29    20      0        0x16db6    0          0x0        0xFFFFF    0.         0.     ditto
# Vdly feedback control ASIC 2
Vdly_VDD2               0x2A    12      20       0x850      0          0x0        0xFFF      0.         0.     ditto
Vdly_Compare2           0x2A    20      0        0x16db6    0          0x0        0xFFFFF    0.         0.     ditto
# Vdly feedback control ASIC 3
Vdly_VDD3               0x2B    12      20       0x850      0          0x0        0xFFF      0.         0.     ditto
Vdly_Compare3           0x2B    20      0        0x16db6    0          0x0        0xFFFFF    0.         0.     ditto
VDEL_ROVDDCalcValues0   0x2C    32      0        0x0      1          0x0        0x0        0.         0.     For ASIC 0 - TBD: Individual bits need to be defined
VDEL_ROVDDCalcValues1   0x2D    32      0        0x0      1          0x0        0x0        0.         0.     For ASIC 1 - TBD: Individual bits need to be defined
VDEL_ROVDDCalcValues2   0x2E    32      0        0x0      1          0x0        0x0        0.         0.     For ASIC 2 - TBD: Individual bits need to be defined
VDEL_ROVDDCalcValues3   0x2F    32      0        0x0      1          0x0        0x0        0.         0.     For ASIC 3 - TBD: Individual bits need to be defined
Unused_0x30            0x30    20      12       0x0      0          0x0        0x0        0.         0.     Unused
ASIC0_Vped              0x30    12      0        0x41A    0          0x0        0xB6C      0.         0.     Vped value from 0 to 2.5V (Max value enforced in hardware is 0xB6C ~2.5V)
Unused_0x31            0x31    20      12       0x0      0          0x0        0xFFFFF    0.         0.     Unused
ASIC1_Vped              0x31    12      0        0x41A    0          0x0        0xB6C      0.         0.     Vped value from 0 to 2.5V (Max value enforced in hardware is 0xB6C ~2.5V)
Unused_0x32            0x32    20      12       0x0      0          0x0        0xFFFFF    0.         0.     Unused
ASIC2_Vped              0x32    12      0        0x41A    0          0x0        0xB6C      0.         0.     Vped value from 0 to 2.5V (Max value enforced in hardware is 0xB6C ~2.5V)
Unused_0x33            0x33    20      12       0x0      0          0x0        0xFFFFF    0.         0.     Unused
ASIC3_Vped              0x33    12      0        0x41A    0          0x0        0xB6C      0.         0.     Vped value from 0 to 2.5V (Max value enforced in hardware is 0xB6C ~2.5V)
Unused_0x34         0x34    32      0        0x0      0          0x0        0x0        0.         0.     Unused
Unused_0x35         0x35    32      0        0x0      0          0x0        0x0        0.         0.     Unused
Unused_0x36         0x36    32      0        0x0      0          0x0        0x0        0.         0.     Unused
Unused_0x37         0x37    32      0        0x0      0          0x0        0x0        0.         0.     Unused
Unused_0x38            0x38    20      12       0x0      0          0x0        0x0        0.         0.     Unused
DC_IN                   0x38    12      0        0xBB8    0          0x0        0x0        0.         0.     DC_IN to bias input voltage value from 0 to 2.047V - Unused    BG: should be 0xBB8 from init_FPGA in T5CameraModule.cc 'SetDCIN(0xBB8);'
Unused_0x39               0x39    20      12       0x0      0          0x0        0x0        0.         0.     Unused
HV                      0x39    12      0        0x0      0          0x0        0xFFF      0.2936     2.6    HV setup voltage value from 0 to 2.047V , correspond to specific selected HV supply. The calibrated values will make you set the Voltage in V
# Zero-suppression control register
Zero_Threshold		0x3A	12		0		0x0		  0			 0x0		0xFF	   0.		  0.	 Set threshold value to compare. Discard if all values under threshold.
Zero_OverflowValue	0x3A	12		12		0x0		  0			 0x0		0xFF	   0.		  0.	 Set overflow value to properly handle overflow
Unused_0x3a		0x3A	6		24		0x0		  0			 0x0		0x3F	   0.		  0.	 Unused
Zero_Test		0x3A	1		30		0x0		  0			 0x0		0x1		   0.		  0.	 Test zero-suppression reporting. Configure system return only enabled channels regarding zero-suppression logic  
Zero_Enable		0x3A	1		31		0x0		  0			 0x0		0x1		   0.		  0.	 Enable zero suppression algorithm. This algorithm discard all suppressed channels  
# ADC 0
Temperature1_Valid      0x3B    1       31       0x0      1          0x0        0x0        0.         0.     ADC 1, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x3B_1           0x3B    3       28       0x0      0          0x0        0x0        0.         0.     Unused
Temperature1            0x3B    12      16       0x0      1          0x0        0x0        0.125      0.     ADC 1, Temperature measured by ADC 1, conversion is T,C = value*0.125, C
Temperature0_Valid      0x3B    1       15       0x0      1          0x0        0x0        0.         0.     ADC 0, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x3B_0           0x3B    3       12       0x0      0          0x0        0x0        0.         0.     Unused
Temperature0            0x3B    12      0        0x0      1          0x0        0x0        0.125      0.     ADC 0, Temperature measured by ADC 0, conversion is T,C = value*0.125, C
# ADC 1
ASIC2_Current_Valid     0x3C    1       31       0x0      1          0x0        0x0        0.         0.     ADC 1 ASIC2, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x3C_1           0x3C    3       28       0x0      0          0x0        0x0        0.         0.     Unused
ASIC2_Current           0x3C    12      16       0x0      1          0x0        0x0        0.00012207 0.    Measured current on ASIC 2, T5CameraModule::GetMeasuredASICCurrent for multiplier (  5. / 4096. / 20. / .5)
ASIC3_Current_Valid     0x3C    1       15       0x0      1          0x0        0x0        0.         0.     ADC 1 ASIC3, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x3C_0           0x3C    3       12       0x0      0          0x0        0x0        0.         0.     Unused
ASIC3_Current           0x3C    12      0        0x0      1          0x0        0x0        0.00012207 0.     Measured current on ASIC 3, T5CameraModule::GetMeasuredASICCurrent for multiplier (  5. / 4096. / 20. / .5)
# ADC 2
ASIC2_Voltage_Valid     0x3D    1       31       0x0      1          0x0        0x0        0.         0.     ADC 2 ASIC2, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x3D_1           0x3D    3       28       0x0      0          0x0        0x0        0.         0.     Unused
ASIC2_Voltage           0x3D    12      16       0x0      1          0x0        0x0        0.0012207  0.     Measured voltage on ASIC 2, T5CameraModule::GetMeasuredASICVoltage for multiplier (5./4096)
ASIC3_Voltage_Valid     0x3D    1       15       0x0      1          0x0        0x0        0.         0.     ADC 2 ASIC3, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x3D_0           0x3D    3       12       0x0      0          0x0        0x0        0.         0.     Unused
ASIC3_Voltage           0x3D    12      0        0x0      1          0x0        0x0        0.0012207  0.     Measured voltage on ASIC 3, T5CameraModule::GetMeasuredASICVoltage for multiplier (5./4096)
# ADC 3
ASIC2_Vped_Meas_Valid   0x3E    1       31       0x0      1          0x0        0x0        0.         0.     ADC 3, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x3E_1           0x3E    3       28       0x0      0          0x0        0x0        0.         0.     Unused
ASIC2_Vped_Meas         0x3E    12      16       0x0      1          0x0        0xFFF      0.0012207  0.     ADC 3, ASIC 2 VPED Voltage, conversion is V = value*5/4096,V
ASIC3_Vped_Meas_Valid   0x3E    1       15       0x0      1          0x0        0x0        0.         0.     ADC 3, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x3E_0           0x3E    3       12       0x0      0          0x0        0x0        0.         0.     Unused
ASIC3_Vped_Meas         0x3E    12      0        0x0      1          0x0        0xFFF      0.0012207  0.     ADC 3, ASIC 3 VPED Voltage, conversion is V = value*5/4096,V
# ADC 4
ASIC2_Vdly_Meas_Valid   0x3F    1       31       0x0      1          0x0        0x0        0.         0.     ADC 4, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x3F_1           0x3F    3       28       0x0      0          0x0        0x0        0.         0.     Unused
ASIC2_Vdly_Meas         0x3F    12      16       0x0      1          0x0        0xFFF      0.0012207  0.     ADC 4, ASIC 2 Vdly, conversion is V = value*5/4096,V T5CameraModule::GetMeasuredVdly
ASIC3_Vdly_Meas_Valid   0x3F    1       15       0x0      1          0x0        0x0        0.         0.     ADC 4, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x3F_0           0x3F    3       12       0x0      0          0x0        0x0        0.         0.     Unused
ASIC3_Vdly_Meas         0x3F    12      0        0x0      1          0x0        0xFFF      0.0012207  0.     ADC 4, ASIC 3  Vdly, conversion is V = value*5/4096,V T5CameraModule::GetMeasuredVdly
# ADC 5
ADC5_Valid1             0x40    1       31       0x0      1          0x0        0x0        0.         0.     ADC 1, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x40_1           0x40    3       28       0x0      0          0x0        0x0        0.         0.     Unused
ASIC2_SumDischargeIsel  0x40    12      16       0x0      1          0x0        0x0        0.00183105 0.     ADC 1, ASIC 2 SUM of DISCHARGE and ISEL Voltage, conversion is V = value*7.5/4096,V
ADC5_Valid0             0x40    1       15       0x0      1          0x0        0x0        0.         0.     ADC 0, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x40_0           0x40    3       12       0x0      0          0x0        0x0        0.         0.     Unused
ASIC3_SumDischargeIsel  0x40    12      0        0x0      1          0x0        0x0        0.00183105 0.     ADC 0, ASIC 3 SUM of DISCHARGE and ISEL Voltage, conversion is V = value*7.5/4096,V
# ADC 6
ASIC0_Current_Valid     0x41    1       31       0x0      1          0x0        0x0        0.         0.     ADC 6 ASIC0, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x41_1           0x41    3       28       0x0      0          0x0        0x0        0.         0.     Unused
ASIC0_Current           0x41    12      16       0x0      1          0x0        0x0        0.00012207 0.     Measured current on ASIC 0, T5CameraModule::GetMeasuredASICCurrent for multiplier (  5. / 4096. / 20. / .5)
ASIC1_Current_Valid     0x41    1       15       0x0      1          0x0        0x0        0.         0.     ADC 6 ASIC1, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x41_0           0x41    3       12       0x0      0          0x0        0x0        0.         0.     Unused
ASIC1_Current           0x41    12      0        0x0      1          0x0        0x0        0.00012207 0.     Measured current on ASIC 1, T5CameraModule::GetMeasuredASICCurrent for multiplier (  5. / 4096. / 20. / .5)
# ADC 7
ASIC0_Voltage_Valid     0x42    1       31       0x0      1          0x0        0x0        0.         0.     ADC 7 ASIC0, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x42_1           0x42    3       28       0x0      0          0x0        0x0        0.         0.     Unused
ASIC0_Voltage           0x42    12      16       0x0      1          0x0        0x0        0.0012207  0.     Measured voltage on ASIC 0, T5CameraModule::GetMeasuredASICVoltage for multiplier (5./4096)
ASIC1_Voltage_Valid     0x42    1       15       0x0      1          0x0        0x0        0.         0.     ADC 7 ASIC1, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x42_0           0x42    3       12       0x0      0          0x0        0x0        0.         0.     Unused
ASIC1_Voltage           0x42    12      0        0x0      1          0x0        0x0        0.0012207  0.     Measured voltage on ASIC 1, T5CameraModule::GetMeasuredASICVoltage for multiplier (5./4096)
# ADC 8
ASIC0_Vped_Meas_Valid   0x43    1       31       0x0      1          0x0        0x0        0.         0.     ADC 1, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x43_1           0x43    3       28       0x0      0          0x0        0x0        0.         0.     Unused
ASIC0_Vped_Meas         0x43    12      16       0x0      1          0x0        0xFFF      0.0012207  0.     ADC 1, ASIC 0 VPED Voltage, conversion is V = value*5/4096,V
ASIC1_Vped_Meas_Valid   0x43    1       15       0x0      1          0x0        0x0        0.         0.     ADC 0, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x43_0            0x43    3       12       0x0      0          0x0        0x0       0.         0.     Unused
ASIC1_Vped_Meas         0x43    12      0        0x0      1          0x0        0xFFF      0.0012207  0.     ADC 0, ASIC 1 VPED Voltage, conversion is V = value*5/4096,V
# ADC 9
ASIC0_Vdly_Meas_Valid   0x44    1       31       0x0      1          0x0        0x0        0.         0.     ADC 9, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x44_1           0x44    3       28       0x0      0          0x0        0x0        0.         0.     Unused
ASIC0_Vdly_Meas         0x44    12      16       0x0      1          0x0        0xFFF      0.0012207  0.     ADC 9, ASIC 0 Vdly, conversion is V = value*5/4096,V T5CameraModule::GetMeasuredVdly
ASIC1_Vdly_Meas_Valid   0x44    1       15       0x0      1          0x0        0x0        0.         0.     ADC 9, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x44_0           0x44    3       12       0x0      0          0x0        0x0        0.         0.     Unused
ASIC1_Vdly_Meas         0x44    12      0        0x0      1          0x0        0xFFF      0.0012207  0.     ADC 9, ASIC 1 Vdly, conversion is V = value*5/4096,V T5CameraModule::GetMeasuredVdly
# ADC 10
ASIC0_SumDischargeIsel_Valid  0x45    1       31       0x0      1          0x0        0x0        0.         0.     ADC 1, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x45_1           0x45    3       28       0x0      0          0x0        0x0        0.         0.     Unused
ASIC0_SumDischargeIsel  0x45    12      16       0x0      1          0x0        0x0        0.00183105 0.     ADC 1, ASIC 0 SUM of DISCHARGE and ISEL Voltage, conversion is V = value*7.5/4096,V
ASIC1_SumDischargeIsel_Valid  0x45    1       15       0x0      1          0x0        0x0        0.         0.     ADC 0, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x45_0           0x45    3       12       0x0      0          0x0        0x0        0.         0.     Unused
ASIC1_SumDischargeIsel  0x45    12      0        0x0      1          0x0        0x0        0.00183105 0.     ADC 0, ASIC 1 SUM of DISCHARGE and ISEL Voltage, conversion is V = value*7.5/4096,V
# ADC 11
MGTSupplyVoltage_Valid  0x46    1       31       0x0      1          0x0        0x0        0.         0.     ADC 1, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x46_1           0x46    3       28       0x0      0          0x0        0x0        0.         0.     Unused
MGTSupplyVoltage        0x46    12      16       0x0      1          0x0        0x0        0.0012207  0.     ADC 1, MGT Supply Voltage, conversion is V = value*5/4096,V
+1.2V_FPGA_Valid        0x46    1       15       0x0      1          0x0        0x0        0.         0.     ADC 0, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x46_0           0x46    3       12       0x0      0          0x0        0x0        0.         0.     Unused
+1.2V_FPGA              0x46    12      0        0x0      1          0x0        0x0        0.0012207  0.     ADC 0, 1.2V FPGA Voltage (2.5V), conversion is V = value*5/4096,V
# ADC 12
+1.8V_FPGA_Valid        0x47    1       31       0x0      1          0x0        0x0        0.         0.     ADC 1, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x47_1           0x47    3       28       0x0      0          0x0        0x0        0.         0.     Unused
+1.8V_FPGA              0x47    12      16       0x0      1          0x0        0x0        0.0012207  0.     ADC 1, 1.8V FPGA Voltage , conversion is V = value*5/4096,V
+2.5V_FPGA_Valid        0x47    1       15       0x0      1          0x0        0x0        0.         0.     ADC 0, Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 - is in conversion.
Unused_0x47_0           0x47    3       12       0x0      0          0x0        0x0        0.         0.     Unused
+2.5V_FPGA              0x47    12      0        0x0      1          0x0        0x0        0.0012207  0.     ADC 0, 2.5V FPGA Voltage , conversion is V = value*5/4096,V
# Trigger efficiency control 0: 0x48
Unused_0x48             0x48   32       0        0x0      0          0x0        0x0        0.         0.     Unused
# Trigger efficiency control 1: 0x49
Unused_0x49             0x49   32       0        0x0      0          0x0        0x0        0.         0.     Unused
# Trigger input counter: 0x4A
Unused_0x4A             0x4A   32       0        0x0      0          0x0        0x0        0.         0.     Unused
# Trigger efficiency counter: 0x4B
Unused_0x4B             0x4B   32       0        0x0      0          0x0        0x0        0.         0.     Unused
# Software reset register: 0x4C
SoftwareReset           0x4C    32      0        0x0      2          0x0        0xFFFFFFFF        0.         0.     Writing value of 0xBECEDACE will start reset of FPGA logic, but keep values programmed into register. Also, write to this register does not generate command response due to transmitter logic reset as well
# Channel enable register 0: 0x4D
EnableChannelsASIC0	0x4d	16		0		0x0 		  0			0x0		0xFFFF	   0.		0.	Enable channels for readout on ASIC 0, bit-mask	
EnableChannelsASIC1	0x4d	16		16		0x0 		  0			0x0		0xFFFF	   0.		0.	Enable channels for readout on ASIC 1, bit-mask	
EnableChannelsASIC2	0x4e	16		0		0x0 		  0			0x0		0xFFFF	   0.		0.	Enable channels for readout on ASIC 2, bit-mask	
EnableChannelsASIC3	0x4e	16		16		0x0 		  0			0x0		0xFFFF	   0.		0.	Enable channels for readout on ASIC 3, bit-mask	
Unused_0x4F_1           0x4F    20     12        0x0      1          0x0        0xFFFFFFFF        0.         0.   Unused
SR_CLK_Mode	        0x4F     1     11        0x1      0          0x0        0x1               0.         0.   Special mode for sr_clk. 0 sr_clk run continuously, 1  sr_clk run when only needed
SpecialTriggerMode      0x4F     1     10        0x0      0          0x0        0x1               0.         0.   Special trigger mode. When set to 1 enable J5 output generate pulse on every sampling buffer turn for 10 event and stop. To reactivate need to bring it back to 0, if 0 - trigger sync command generated ~ at 1kHz
ExtTriggerDirection     0x4F     1      9        0x0      0          0x0        0x1               0.         0.   To control direction of External Trigger IO, 0  input, 1 - output
Unused_0x4F_2           0x4F     9      0        0x0      1          0x0        0x1               0.         0.   Unused
# Write Target 
WriteTargetValue		0x50	12		0		0x0		  1			 0x0		0xFFF      0.		  0.	 Target register value to write. See Target 7 documentation for specific registers and bit allocation, set to read only so it is skipped in initialisation, interface is through WriteASICSetting
WriteTargetAdress		0x50	7		12		0x0		  1			 0x0		0x7F       0.		  0.	 Target register address to write. See Target 7 documentation for specific register address map., set to read only so it is skipped in initialisation, interface is through WriteASICSetting
EnableLatching			0x50	1		19		0x0		  1			 0x0		0x1        0.		  0.	 Define if data latching on Target is required. 0 – latching is required, 1 – no latching., set to read only so it is skipped in initialisation, interface is through WriteASICSetting
ReadBackImmediately		0x50	1		20		0x0		  1			 0x0		0x1        0.		  0.	 If bit 19 is set (1) read back followed immediately after write. Otherwise, read of previously written register, set to read only so it is skipped in initialisation, interface is through WriteASICSetting
EnableWriteASIC0		0x50	1		21		0x1		  1			 0x0		0x1        0.		  0.	 Enable (1) write/read operation to ASIC 0. Set to read only so it is skipped in initialisation, interface is through WriteASICSetting
EnableWriteASIC1		0x50	1		22		0x1		  1			 0x0		0x1        0.		  0.	 Enable (1) write/read operation to ASIC 1, set to read only so it is skipped in initialisation, interface is through WriteASICSetting
EnableWriteASIC2		0x50	1		23		0x1		  1			 0x0		0x1        0.		  0. 	 Enable (1) write/read operation to ASIC 2, set to read only so it is skipped in initialisation, interface is through WriteASICSetting
EnableWriteASIC3		0x50	1		24		0x1		  1			 0x0		0x1        0.		  0.	 Enable (1) write/read operation to ASIC 3, set to read only so it is skipped in initialisation, interface is through WriteASICSetting
Unused_0x50			0x50	7		25		0x1		  1			 0x0		0x0        0.		  0.     Unused
# Read Target 0	
ReadTargetASIC0			0x51	12		0		0x0		  1			 0x0		0x0        0.		  0.	 Read back value from ASIC 0. Updated after Target ASIC operation enabled in register 0x40(bit 20). If bit 19 is set (1) read back followed immediately after write. Otherwise, read of previously written register 
Unused_0x51_0			0x51	4		12		0x0		  0			 0x0		0x0        0.		  0. 	 Unused
ReadTargetASIC1			0x51	12		16		0x0		  1			 0x0		0x0        0.		  0.	 Read back value from ASIC 0. Updated after Target ASIC operation enabled in register 0x40(bit 20). If bit 19 is set (1) read back followed immediately after write. Otherwise, read of previously written register 
Unused_0x51_1			0x51	4		28		0x0		  0			 0x0		0x0        0.		  0.. 	 Unused 
# Read Target 1
ReadTargetASIC2			0x52	12		0		0x0		  1			 0x0		0x0        0.		  0.	 Read back value from ASIC 0. Updated after Target ASIC operation enabled in register 0x40(bit 20). If bit 19 is set (1) read back followed immediately after write. Otherwise, read of previously written register 
Unused_0x52_0			0x52	4		12		0x0		  0			 0x0		0x0        0.		  0.. 	 Unused 
ReadTARGETASIC3			0x52	12		16		0x0		  1			 0x0		0x0        0.		  0.	 Read back value from ASIC 0. Updated after Target ASIC operation enabled in register 0x40(bit 20). If bit 19 is set (1) read back followed immediately after write. Otherwise, read of previously written register 
Unused_0x52_1			0x52	4		28		0x0		  0			 0x0		0x0        0.		  0.. 	 Unused
PacketDelay              0x53   32      0        0x0      0          0x0        0xFFFFFFFF 8.         0.     Delay between packets sent from TM, 32 bits in 8 ns steps      
