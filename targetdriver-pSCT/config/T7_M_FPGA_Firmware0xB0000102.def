####################################################################
# NEVER CHANGE THIS FILE
#
# Definitions of register values and partial register values.
#
# If Firmware changes generate a new definition file specifying
# the firmware version in the name.
#
# Setting AccesMode can take 3 values 0 = Read/Write, 1 = Read Only ,2 = Write Only (no response), 3 = Read/Non sticky write;
####################################################################
HEADER
TM_TYPE TM_7_BP
TM_FIRMWARE_VERSION 0xB0000102
DESCRIPTION This is firmware version 0xB0000102, which is the up-to-date version for TARGET 7 modules as of March 31 2016. Mods w.r.t. to B0000100: fixed problem with WR clock and event delay.
RESPONSIBLE_AUTHOR Luigi Tibaldo
NUM_REGISTERS 0x81
##############################################################################################
# Setting layout: All fields must be filled, use 0 for default value.
#
# Field: Name           RegAddr nBits   startBit value    AccessMode    lowerBound upperBound multiplier offset description
# Type:  string         uint8_t uint8_t uint8_t  uint32_t enum(0,1,2,3) uint32_t   uint32_t   float      float  strings
##############################################################################################
SETTINGS
FirmwareVersion         0x00    32      0       0xB0000102      1          0x0        0x0        0.         0.     Assigned value of 0xFED00001, assigned in Firmware to highlight and track incremental changes in firmware. Incremented with every firmware revision
CTAID                   0x01    8       0       0x0       0          0x0        0xFF       0.         0.     CTA ID, fill CTA ID field of reported event
DetectorID              0x01    8       8       0x0       0          0x0        0xFF       0.         0.     Detector ID, fill Detector ID field of reported event
AnyValue                0x01    16      16      0x0       0          0x0        0xFFFF     0.         0.     Any value for control software, does not have effect on any FPGA logic
SerialNumLSW            0x02    32      0       0x0       1          0x0        0x0        0.         0.     Serial number the least significant word
SerialNumMSW            0x03    32      0       0x0       1          0x0        0x0        0.         0.     Serial number the most significant word
# Status registe
VCCAUX_ALRM				0x04	1		0		0x0		  1	         0x0		0x0		   0.		  0.	 VCCAUX_ALARM_OUT from FPGA monitoring, see FPGA monitoring section (temperature)
VCCINT_ALRM				0x04	1		1		0x0		  1	         0x0		0x0		   0.		  0.	 VCCINT_ALARM_OUT from FPGA monitoring, see FPGA monitoring section (Vccint)
USR_VCCAUX_ALRM			0x04	1		2		0x0		  1	         0x0		0x0		   0.		  0.	 USER_TEMP_ALARM_OUT from FPGA monitoring, see FPGA monitoring section (Vccaux)
USR_VCCBRAM__ALRM		0x04	1		3		0x0		  1	         0x0		0x0		   0.		  0.	 USER_TEMP_ALARM_OUT from FPGA monitoring, see FPGA monitoring section (Vccbram)
BUSY_FPGA_MON			0x04	1		4		0x1		  1	         0x0		0x0		   0.		  0.	 BUSY from FPGA monitoring, ADC busy signal. This signal transitions High during an ADC conversion. This signal also transitions High for an extended period during an ADC or sensor calibration, see FPGA monitoring section
DRDY_FPGA_MON			0x04	1		5	 	0x0		  1	         0x0		0x0		   0.		  0.	 DRDY from FPGA monitoring, see FPGA monitoring section
EOC_FPGA_MON			0x04	1		6		0x0		  1	         0x0		0x0		   0.		  0.	 EOC from FPGA monitoring. This signals transitions to an active High at the end of an ADC conversion when the measurement is written to the status register, see FPGA monitoring section
EOS_FPGA_MON			0x04	1		7		0x0		  1	         0x0		0x0		   0.		  0.	 EOS from FPGA monitoring. This signal transitions to active High when the measurement data from the last channel in an automatic channel sequence is written to the status registers, see FPGA monitoring section
OVER_TMP_FPG_MON		0x04	1		8		0x0		  1	         0x0		0x0		   0.		  0.	 OT (Over-Temperature alarm) from FPGA monitoring, see FPGA monitoring section
+5.2V_OK			0x04	1		9		0x1		  1	         0x0		0x0		   0.		  0.	 +5_2V for Peltier and Preamp OK, 1 - OK, 0 - is not
+1.8V_OK			0x04	1		10		0x1		  1	         0x0		0x0		   0.		  0.	 +1_8V is OK, 1 - OK, 0 - is not
mgt_AVCC_OK			0x04	1		11		0x1		  1	         0x0		0x0		   0.		  0.	 mgt_AVCC_OK is OK, 1 - OK, 0 - is not
mgt_AVTT_OK			0x04	1		12		0x0		  1	         0x0		0x0		   0.		  0.	 mgt_AVTT_OK is OK, 1 - OK, 0 - is not
Unused_0x04_0			0x04	2		13		0x0		  1			 0x0		0x0		   0.		  0.	 Unused
EventDone_ASIC0			0x04	1		15		0x0		  1	         0x0		0x0		   0.		  0.	 State of event Done bit ASIC 0
EventDone_ASIC1			0x04	1		16		0x0		  1	         0x0		0x0		   0.		  0.	 State of event Done bit ASIC 1
EventDone_ASIC2			0x04	1		17		0x0		  1	         0x0		0x0		   0.		  0.	 State of event Done bit ASIC 2
EventDone_ASIC3			0x04	1		18		0x0		  1	         0x0		0x0		   0.		  0.	 State of event Done bit ASIC 3
FIFO_Overflow			0x04	1		19		0x0		  1	         0x0		0x0		   0.		  0.	 Overflow on summary FIFO of event data
FIFO_Underflow			0x04	1		20		0x0		  1	         0x0		0x0		   0.		  0.	 Underflow on summary FIFO of event data
Unused_0x04_1			0x04	6		21		0x0		  1	         0x0		0x0		   0.		  0.	 Unused, always 0
BackPlaneStatus			0x04	5		27		0x13	  1	         0x0		0x0		   0.		  0.	 Status of backplane lines from bp4 to bp7 (also bp5 is reset and will not be available due to board reset)
# Latched status register
LatchedVCCAUX_ALRM		0x05	1		0		0x0		  1	         0x0		0x0		   0.		  0.	 VCCAUX_ALARM_OUT from FPGA monitoring, see FPGA monitoring section (temperature) 
LatchedVCCINT_ALRM		0x05	1		1		0x0		  1	         0x0		0x0		   0.		  0.	 VCCINT_ALARM_OUT from FPGA monitoring, see FPGA monitoring section (Vccint) 
LatchedUSR_VCCAUX_ALRM	0x05	1		2		0x0		  1	         0x0		0x0		   0.		  0.	 USER_TEMP_ALARM_OUT from FPGA monitoring, see FPGA monitoring section (Vccaux) 
LatchedUSR_VCCBRAM_ALRM	0x05	1		3		0x0		  1	         0x0		0x0		   0.		  0.	 USER_TEMP_ALARM_OUT from FPGA monitoring, see FPGA monitoring section (Vccbram)	 
LatchedBUSY_FPGA_MON	0x05	1		4		0x1		  1	         0x0		0x0		   0.		  0.	 BUSY from FPGA monitoring, ADC busy signal. This signal transitions High during an ADC conversion. This signal also transitions High for an extended period during an ADC or sensor calibration, see FPGA monitoring section 
LatchedDRDY_FPGA_MON	0x05	1		5		0x0		  1	         0x0		0x0		   0.		  0.	 DRDY from FPGA monitoring, see FPGA monitoring section 
LatchedEOC_FPGA_MON		0x05	1		6		0x1		  1	         0x0		0x0		   0.		  0.	 EOC from FPGA monitoring. This signals transitions to an active High at the end of an ADC conversion when the measurement is written to the status register, see FPGA monitoring section 
LatchedEOS_FPGA_MON		0x05	1		7		0x1		  1	         0x0		0x0		   0.		  0.	 EOS from FPGA monitoring. This signal transitions to active High when the measurement data from the last channel in an automatic channel sequence is written to the status registers, see FPGA monitoring section 
LatchedOVER_TMP_FPG_MON	0x05	1		8		0x0		  1	         0x0		0x0		   0.		  0.	 OT (Over-Temperature alarm) from FPGA monitoring, see FPGA monitoring section 
Latched+5.2V_OK			0x05	1		9		0x1		  1	         0x0		0x0		   0.		  0.	 +5_2V for Peltier and Preamp OK, 1 - OK, 0 - is not 
Latched+1.8V_OK			0x05	1		10		0x1	  	  1	         0x0		0x0		   0.		  0.	 +1_8V is OK, 1 - OK, 0 - is not
Latchedmgt_AVCC_OK		0x05	1		11		0x1		  1	         0x0		0x0		   0.		  0.	 mgt_AVCC_OK is OK, 1 - OK, 0 - is not
Latchedmgt_AVTT_OK		0x05	1		12		0x1		  1	         0x0		0x0		   0.		  0.	 mgt_AVTT_OK is OK, 1 - OK, 0 - is not
Unused_0x05_0		0x05	2		13		0x0		  1	         0x0		0x0		   0.		  0.	 Unused
LatchedEventDone_ASIC0	0x05	1		15		0x0		  1	         0x0		0x0		   0.		  0.	 State of event Done bit ASIC 0
LatchedEventDone_ASIC1	0x05	1		16		0x0		  1	         0x0		0x0		   0.		  0.	 State of event Done bit ASIC 1
LatchedEventDone_ASIC2	0x05	1		17		0x0		  1	         0x0		0x0		   0.		  0.	 State of event Done bit ASIC 2
LatchedEventDone_ASIC3	0x05	1		18		0x0		  1	         0x0		0x0		   0.		  0.	 State of event Done bit ASIC 3
LatchedFIFOOverflow	0x05	1		19		0x0		  1	         0x0		0x0		   0.		  0.	 Overflow on summary FIFO of event data
LatchedFIFOUnderflow	0x05	1		20		0x0		  1	         0x0		0x0		   0.		  0.	 Underflow on summary FIFO of event data
Unused_0x05_1		0x05	6		21		0x0		  1	         0x0		0x0		   0.		  0.	 Unused, always 0
LatchedBackPlaneStatus	0x05	5		27		0x13	  1	         0x0		0x0		   0.		  0.	 Status of backplane lines from bp4 to bp7 (also bp5 is reset and will not be available due to board reset)
FIFOStatus_0			0x06	32		0		0x0		  1	         0x0		0x0		   0.		  0.	 Data Storage FIFO underflow(bits 1,3,5,7,..) and overflow (0,2,4,..) errors. Two bits per acquisition channel. Channel 0 errors reported in bits 0(underflow) and 1(overflow), channel 1 in bits 2 and 3,….
LatchedFIFOStatus_0		0x07	32		0		0x0		  0	         0x0		0x1		   0.		  0.	 Data Storage FIFO underflow(bits 1,3,5,7,..) and overflow (0,2,4,..) errors. Two bits per acquisition channel. Channel 0 errors reported in bits 0(underflow)  and 1(overflow),  channel  1  in  bits  2  and  3,….  
FIFOStatus_1			0x08	32		0		0x0		  1	         0x0		0x0		   0.		  0.	 Data Storage FIFO underflow(bits 1,3,5,7,..) and overflow (0,2,4,..) errors. Two bits per acquisition channel. Channel 0 errors reported in bits 0(underflow)  and 1(overflow),  channel  1  in  bits  2  and  3,….  
LatchedFIFOStatus_1		0x09	32		0		0x0		  0	         0x0		0x1		   0.		  0.	 Data Storage FIFO underflow(bits 1,3,5,7,..) and overflow (0,2,4,..) errors. Two bits per acquisition channel. Channel 0 errors reported in bits 0(underflow)  and 1(overflow),  channel  1  in  bits  2  and  3,….  
FIFOStatus_2			0x0a	32		0		0x0		  1	         0x0		0x0		   0.		  0.	 Data Storage FIFO underflow(bits 1,3,5,7,..) and overflow (0,2,4,..) errors. Two bits per acquisition channel. Channel 0 errors reported in bits 0(underflow)  and 1(overflow),  channel  1  in  bits  2  and  3,….  
LatchedFIFOStatus_2		0x0b	32		0		0x0		  0	         0x0		0x1		   0.		  0.	 Data Storage FIFO underflow(bits 1,3,5,7,..) and overflow (0,2,4,..) errors. Two bits per acquisition channel. Channel 0 errors reported in bits 0(underflow)  and 1(overflow),  channel  1  in  bits  2  and  3,….  
FIFOStatus_3			0x0c	32		0		0x0		  1	         0x0		0x0		   0.		  0.	Data Storage FIFO underflow(bits 1,3,5,7,..) and overflow (0,2,4,..) errors. Two bits per acquisition channel. Channel 0 errors reported in bits 0(underflow)  and 1(overflow),  channel  1  in  bits  2  and  3,….   
LatchedFIFOStatus_3		0x0d	32		0		0x0		  0	         0x0		0x1		   0.		  0.	Data Storage FIFO underflow(bits 1,3,5,7,..) and overflow (0,2,4,..) errors. Two bits per acquisition channel. Channel 0 errors reported in bits 0(underflow)  and 1(overflow),  channel  1  in  bits  2  and  3,….   
TriggerFIFOStatus 		0x0e	32		0		0x0		  1	         0x0		0x0		   0.		  0.	 
# Trigger Statistics
CountTACKsReceived		0x0f	16		0		0x0		  3	         0x0		0x1	   	   0.		  0.	 Count number of TACKs received
CountGoodSyncTACKs		0x0f	16		16		0x0		  3	         0x0		0x1		   0.		  0.	 Count number of good Sync verification TACKs.
# TACK statistics
CountTACKParityErrors	0x10	8		0		0x0		  1	         0x0		0x1	   	   0.		  0.	 Count Tack Parity errors. Counter is reset by writing any value into register 0xF
CountTACKParityErrors2	0x10	8		8		0x0		  1		     0x0		0x1		   0.		  0.	 Same as count in bits 7-0.   Count Tack Parity errors
CountTACKRangeErrors	0x10	8		16		0x0		  1	         0x0		0x1		   0.		  0.	 Count of range error over Tack. Counter is reset by writing any value into register 0xF
CountSyncErrors 		0x10	8		24		0x0		  1	         0x0		0x1		   0.		  0.	 Count of range error over Tack. Counter is reset by writing any value into register 0xF
# FIFO statistics
CountDataPackets 		0x11	16		0		0x0		  1	         0x0		0x1	  	   0.		  0.	 Count all built packets on all incoming channels. Counter is reset by writing any value into register 0xF
CountDataPacketsEnabled		0x11	16		16		0x0		  1	         0x0		0x1		   0.		  0.	 Count all enabled for counting (bits 0 of register 0x30) built packets on all incoming channels. Counter is reset by writing any value into register 0xF
# Packet statistics	
CountTransmittedPackets	0x12	16		0		0x0		  1	         0x0		0x1		   0.		  0.	 MAC Counter, count all transmitted packet by MAC. Counter is reset by writing any value into register 0xF
CountTransmittedPackets2	0x12	16		16		0x0		  1	         0x0		0x1		   0.		  0.	 Copy of bits 15-0,  Counter is reset by writing any value into register 0xF
# Ramp count statistics
CountProcessedEvents	0x13	16		0		0x0		  1	         0x0		0x1		   0.		  0.	 Count number of event processed. Counter is reset by writing value of 1 into bit 30 of register 0x1a
CountCommandPackets		0x13	16		16		0x0		  1	         0x0		0x1	       0.		  0.	 Count command issued to Camera module. Counter is reset by writing any value into register 0xF
# Time Adjust Register
Time_Offset				0x14	8		0		0x60	  0			 0x0		0xFF	   8.		  0.	 Time offset register, specify amount of clock cycles to adjust timebase between tester and camera module to start simultaneously (8 ns steps)
Unused_0x14			0x14	8		8		0x0		  0	         0x0		0x0		   0.		  0.	 Unused 
Correct_TACK			0x14	15		16		0x0		  0	         0x0		0x7FFF	   1.		  0.	 To correct TACK for proper time by taking in to account propagation and decision making (1 ns steps) 
Start_TimeBase			0x14	1		31		0x0		  0			 0x0		0x1		   0.		  0.	 Start time base writing 1 to this bit will start and restart time base. Time base always start from 0 
# ADC configuration Registers
ADC0SelectScanMode		0x15	1		0		0x0		  0			 0x0		0x1		   0.		  0.	 ADC 0 logic, Select scan mode, bit 0 of scan bits http://datasheets.maxim-ic.com/en/ds/MAX1227-MAX1231.pdf 0- Select readout of channels from 0 through N, 1- from N to highest numbered channel. Must be set to 0 
ADC0ChannelSelect		0x15	4		1		0xF		  0			 0x0		0xF		   0.		  0.	 ADC 0 logic, Channel select bits, Set to b1111 to read all 16 channels http://datasheets.maxim-ic.com/en/ds/MAX1227-MAX1231.pdf Must be set to b1111 
ADC0Averaging			0x15	3		5		0x0		  0			 0x0		0x7		   0.		  0.	 ADC 0 logic, Select averaging and number of averages http://datasheets.maxim-ic.com/en/ds/MAX1227-MAX1231.pdf 0xx  perform one conversion for each result 100 - perform four conversions and return average for each result 101 - perform eight conversions and return average for each result 110 - perform 16 conversions and return average for each result 111 - perform 32 conversions and return average for each result 
ADCEnableSelect			0x15	4		8		0xF		  0			 0x0		0xF		   0.		  0.	 Select set of ADC enables, one bit per ADC (bit 4  ADC 8 for ASIC 0,  bit 9  ADC  1  for  ASIC  1,  …,  bit  11  ADC 3 for ASIC 3) 
Unused_0x15			0x15	18		12		0x0		  1			 0x0		0x0		   0.		  0.	 Unused 
ADCStop				0x15	1		30		0x0		  0			 0x0		0x1		   0.		  0.	 ADC stop, will stop ADC update 
ADCStart			0x15	1		31		0x0		  0			 0x0		0x1		   0.		  0.	 ADC start (1), non sticky, will start/restart  reconfiguration and conversion 
TimeCounter			0x16	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Free running time counter value set by sync over TACK pass 32 LSB
# Control register 0
EnableBit				0x17	1		0		0x1		  1			 0x0		0x1		   0.		  0.	 Enable bit, 1- enable analog sampling, after proper Sync command issued
Unused_0x17	0x17	1		1		0x0		  0			 0x0		0x0		   0.		  0.	 Unused
OffsetUsageEnable		0x17	1		2		0x0		  0			 0x0		0x1		   0.		  0.	 Offset usage enable (1).  In order to optimize 48 samples readout relatively to trigger position, logic implement option to sync readout to 8 sample bins (4 bins per buffer). Setting bit to one will enable this feature. Otherwise buffer readout always start from beginning. Should be noted that that setting number of readout buffer to more then 2( Bits 23-20) will disable offset usage. And for software buffer this feature disabled as well (bit 9 of 0x1b)  
RampStartDelay			0x17	5		3		0x0		  0			 0x0		0x1F	   8.		  0.	 Ramp start delay after trigger, in system clocks (8 ns)  
RampSignalDuration		0x17	13		8		0x7D0	  0			 0x0		0x1FFF	   0.		  0.	 Specify ramp signal duration to Target 
SR_SEL_Mode				0x17	1		21		0x0		  0			 0x0		0x1		   0.		  0.	 Select if SR_SEL pulse signal asserted all time (1)  or only actual event readout process   
SR_CLK_Mode				0x17	1		22		0x1		  0			 0x0		0x1		   0.		  0.	 Special mode for sr_clk. 0  sr_clk run continuously, 1  sr_clk run when only needed   
Options_BufferNotIncr	0x17	1		23		0x0		  0			 0x0		0x1		   0.		  0.	 Select options when buffer never incremented, stay same as start one 
MaxChannelsInPacket		0x17	7		24		0x0		  0			 0x0		0x7F	   0.		  0.	 Maximum Ethernet packet size parameter. Indicate how many channels out of available 64 can be shipped in one packet. Value of 0 and 1 indicate one channel per network packet, 2  channels  per  packet,  and  … Careful attention need to be taken to set this parameter. First of all user need to know type of network card host system will have and if it support Jumbo packets. In any case maximum size of acceptable network packet need to be compared with expected event size and properly divided into packets. Default value of 0 (or 1) always process just one channel per packet and works in all cases but will generate maximum number of packets (64). This parameter help to reduce number of packets and related overhead for packet header and trailer to optimize system performance.
EnablePacketCount		0x17	1		31		0x0		  0			 0x0		0x1		   0.		  0.	 Enable packet count in register 0x10, bits 31-16
# Control register 1
PowerUpASIC0  			0x18	1		0		0x0		  0			 0x0		0x1		   0.		  0.	 Power up ASIC 0 bit. (0 turn off 2.5V to ASIC, 1 -  turn on 2.5V to ASIC)
CLR_REG0  				0x18	1		1		0x0		  0			 0x0		0x1		   0.		  0.	 Directly control clr_reg input to Target ASIC 0
Unused_0x18_0		0x18	2		2		0x0		  0			 0x0		0x0	       0.		  0.	 Unused, Spare control bits to Target ASIC 0
PowerUpASIC1  			0x18	1		4		0x0		  0			 0x0		0x1		   0.		  0.	 Power up ASIC 1 bit. (0 turn off 2.5V to ASIC, 1 -  turn on 2.5V to ASIC)
CLR_REG1  				0x18	1		5		0x0		  0			 0x0		0x1		   0.		  0.	 Directly control clr_reg input to Target ASIC 1
Unused_0x18_1  		0x18	2		6		0x0		  0			 0x0		0x0	       0.		  0.	 Unused, Spare control bits to Target ASIC 1
PowerUpASIC2  			0x18	1		8		0x0		  0			 0x0		0x1		   0.		  0.	 Power up ASIC 2 bit. (0 turn off 2.5V to ASIC, 1 -  turn on 2.5V to ASIC)
CLR_REG2  				0x18	1		9		0x0		  0			 0x0		0x1		   0.		  0.	 Directly control clr_reg input to Target ASIC 2
Unused_0x18_2  		0x18	2		10		0x0		  0			 0x0		0x0		   0.		  0.	 Unused, Spare control bits to Target ASIC 2
PowerUpASIC3  			0x18	1		12		0x0		  0			 0x0		0x1		   0.		  0.	 Power up ASIC 3 bit. (0 turn off 2.5V to ASIC, 1 -  turn on 2.5V to ASIC)
CLR_REG3  				0x18	1		13		0x0		  0			 0x0		0x1		   0.		  0.	 Directly control clr_reg input to Target ASIC 3
Unused_0x18_3		0x18	2		14		0x0		  0			 0x0		0x0		   0.		  0.	 Unused, Spare control bits to Target ASIC 3
HV_Enable				0x18	1		16		0x0		  0			 0x0		0x1		   0.		  0.	 HV enable signal, 1- switch on distribution to FE, 0 disabled If overcurrent is detected, check voltage on MAX11616 ADC, to see if it still distributing to FE, otherwise, toggle bit to enable voltage again 
5.2V_Enable				0x18	1		17		0x1		  0			 0x0		0x1		   0.		  0.	 Enable 5.2V distribution to Aux board, 1- on, 0  off  
2.7V_Enable				0x18	1		18		0x1		  0			 0x0		0x1		   0.		  0.	 Enable 2.7V distribution to Peltier Controller Aux board, 1- on, 0  off  
Unused_0x18_4		0x18	1		19		0x0		  0			 0x0		0x0		   0.		  0.	 Unused
DoneSignalSpeedUp		0x18	1		20		0x0		  0			 0x0		0x1		   0.		  0.	 Select if done signal is used to speed up conversion (1  done is enabled)
BufferEnableLogic		0x18	1		21		0x1	  0			 0x0		0x1		   0.		  0.	 Select buffer enable logic. With current sampling timing this bit need to be set to 1. All odd buffers will get incremented earlier and as result special counting as increment by 3 and decrement by 1 need to be used (Set to 1) 
WilkinsonClockFreq		0x18	2		22		0x0		  0			 0x0		0x3		   0.		  0.	 Select Wilkinson clock frequency divided by 2: 00 - 104MHz, 01 - 62.5MHZ, 10 - 250MHz, 11 - 250MHz 	 
SelectSampleClockPhase	0x18	4		24		0x0		  0			 0x0		0xF		   0.		  0.	 Select phase of clock to sample event data from ASICs, 1 per ASIC (0  rising edge, 1 - falling edge) ASIC0  bit 24, ASIC1  bit  25,  …,  ASIC3   bit 27) 	 
Unused_0x18_5		0x18	4		28		0x0		  0			 0x0		0x0		   0.		  0.	 Unused, Spare control bits  
# Trigger control register 0
TriggerDelayAlternative	0x19	14		0		0x0		  0			 0x0		0xF		   1.		  0.	 Trigger delay alternative, to compensate for time between trigger arrival and trigger decision making, need to be found experimentally. Count in 1ns steps 	
Unused_0x19		0x19	4		14		0x0		  0			 0x0		0x0		   0.		  0.	 Unused	
TriggerDelay			0x19	14		18		0x70	  0			 0x0		0x3FFFF	   1.		  0.	 Trigger delay, to compensate for time between trigger arrival and trigger decision making, need to be found experimentally. Count in 1ns steps
# Trigger control register 1
PhaseOfTACKClock		0x1a	1		0		0x0		  0			 0x0		0x1		   0.		  0.	 Select phase of clock to sample TACK from BP (0  rising edge, 1 - falling edge) 	 
Unused_0x1a_0		0x1a	7		1		0x0		  0			 0x0		0x0		   0.		  0.	 Unused	 	
EnableTriggerInput		0x1a	18		8		0x0		  0			 0x0		0x3FFF	   0.		  0.	 Enable trigger input contribution to trigger counter(register 0xF bits 31-16). Bits assigned as followed: 3-0 : Target ASIC 0 trigger bits, 7-4 : Target ASIC 1 trigger bits, 11-8 : Target ASIC 3 trigger bits, 15-12 : Target ASIC 3 trigger bits,16 : external hardware trigger, 17 : software trigger 
Unused_0x1a_1		0x1a	4		26		0x0		  0			 0x0		0x0		   0.		  0.	 Unused
TriggerCounterReset		0x1a	1		30		0x0		  0			 0x0		0x1		   0.		  0.	 Trigger counter reset 
InitiateSoftwareTrig	0x1a	1		31		0x0		  0			 0x0		0x1		   0.		  0.	 Unused -Software trigger, non sticky bit, need to be set to one to initiate software trigger, does not require to set to 0 to generate next trigger    
# Row/column control/status
Row						0x1b	3		0		0x0		  0			 0x0		0x7		   0.		  0.	 Specify row for readout when trigger received and activated by TACK Mode = "10" OR  "11"	 
Column					0x1b	6		3		0x0		  0			 0x0		0x3F	   0.		  0.	 Specify column for readout when trigger received and activated by TACK Mode = "10" OR  "11"  	 	 
Unused_0x1b			0x1b	1		9		0x0		  0			 0x0		0x0		   0.		  0. 	 Unused	 
CurrentColumn			0x1b	6		10		0x0		  1			 0x0		0x0		   0.		  0.	 Free running current column value to simulate sampling buffer write column pointer    	 
CurrentRow			0x1b	3		16		0x0		  1			 0x0		0x0		   0.		  0.	 Free running current row value to simulate sampling buffer write row pointer	 
LatestSample			0x1b	4		19		0x0		  1			 0x0		0x0		   0.		  0.	 Latched by latest trigger value of sample value  (only 4 MSB)  	 
LatestColumn			0x1b	6		23		0x0		  1			 0x0		0x0		   0.		  0.	 Latched by latest trigger value of column counter   
LatestRow			0x1b	3		29		0x0		  1			 0x0		0x0		   0.		  0.	 Latched by latest trigger value of row counter   
# Number of samples to read
NumberOfBlocks			0x1c	4		0		0x1		  0			 0x0		0xF		   0.		  0.	 Specify number of buffer for readout, with 0 corresponding to 1 buffers 
NumSampOnPartBlock		0x1c	5		4		0x0		  0			 0x0		0x1F	   0.		  0.	 Number of samples on partial buffer, from 0 to 31, to enable flexible readout of any number of desirable samples. At the moment value of 1 -> 16 samples, 0  0 samples. Optimized for 48 sample event  	 
UnusedNumberOfSamples0	0x1c	7		9		0x0		  1			 0x0		0x0		   0.		  0.	 Unused	 
AltNumberOfBlocks		0x1c	4		16		0x0		  0			 0x0		0xF		   0.		  0.	 Specify number of alternative buffer for readout, with 0 corresponding to 1 buffers 
Unused_0x1c		0x1c	12		20		0x0		  1			 0x0		0x0		   0.		  0.	 Unused	 
# Monitor control register
InputFPGAMonitoring		0x1d	16		0		0x0		  0			 0x0		0xFFFF	   0.		  0.	 Input data for FPGA monitoring  interface, DI on page 14 of http://www.xilinx.com/support/documentation/user_guides/ug480_7Series_XADC.pdf 
AddressFPGAMonitoring	0x1d	7		16		0x0		  0			 0x0		0x7F	   0.		  0.	 Data address for FPGA monitoring  interface, DADDR on page 14 of http://www.xilinx.com/support/documentation/user_guides/ug480_7Series_XADC.pdf 
Unused_0x1d		0x1d	8		23		0x0		  0			 0x0		0x0		   0.		  0.	 Unused	 
WriteFPGAMonitoring		0x1d	1		31		0x0		  0			 0x0		0x1		   0.		  0.	 Data write for FPGA monitoring  interface, DWE on page 14 of http://www.xilinx.com/support/documentation/user_guides/ug480_7Series_XADC.pdf	 
# Configuration waveform register
PCLK_SINlow 			0x1e	8		0		0x12	 	  0			 0x0		0xFF	   0.		  0. 	 PCLK width plus 1 when SIN low, need to be set to 0x7 	 
SIN_beforePCLK			0x1e	8		8		0x5		  0			 0x0		0xFF	   0.		  0.	 SIN settling time before PCLK plus 1, need to set to 1	 
SIN_afterPCLK			0x1e	8		16		0x5		  0			 0x0		0xFF	   0.		  0.	 SIN settling time after PCLK plus 1, need to set to 1 
PCLK_SINhigh			0x1e	8		24		0x12	      0			 0x0		0xFF	   0.		  0.	 PCLK width plus 1 when SIN high, need to be set to 0x3 
# ADC11616 control register
MAX11616_Config			0x1f	8		0		0x0		  0			 0x0		0xFF	   0.		  0.	 Configuration byte for MAX11616, see configuration/setup bytes definitions, default 0x17 http://datasheets.maximintegrated.com/en/ds/MAX11612-MAX11617.pdf (Table 2)  
MAX11616_Setup			0x1f	8		8		0x0		  0			 0x0		0xFF	   0.		  0.	 Setup byte for MAX11616, see configuration/setup bytes definitions, default 0xd2 http://datasheets.maximintegrated.com/en/ds/MAX11612-MAX11617.pdf (Table 1) 	 				
MAX11616_Stop			0x1f	1		16		0x0		  0			 0x0		0x1		   0.		  0.	 Stop bit, to change configuration operation needs to be stopped and restarted again 
Unused_0x1f			0x1f	14		17		0x0		  1			 0x0		0x0		   0.		  0.	 Unused
MAX11616_Start			0x1f	1		31		0x0		  0			 0x0		0x1		   0.		  0.	 Setting to 1 will start ADC readout, non-sticky bit	 
# HV control
HVDACControl			0x20	4		0		0x0		  0			 0x0		0xF		   0.		  0.	 Select DAC used for control operation 1 enable control, 0 disable , Bit 0 for DAC 0 (ASIC 0), Bit 1 for DAC 1 (ASIC 1),.., Bit 3 for DAC 3 (ASIC 3) 	 
Unused_0x20		0x20	7		4		0x0		  0			 0x0		0x0		   0.		  0.	 Unused	 
SelectLowSideVoltage	0x20	1		11		0x0		  0			 0x0		0x1		   0.		  0.	 Load Low voltage side DAC, need to be set to 1	 
LowSideVoltage		0x20	20		12		0x0		  0			 0x0		0xFFFFF	   0.		  0.	 HV low side 0 to XX V. Direct Write to configuration space of MAX5715.	 
# Peltier uC control
Peltier_StartComm	0x21	1		0		0x0		  0			 0x0		0x1		   0.		  0.	 Enable start of communication over SPI, 1  start of operation. Need to be 1 for both programming and normal mode for SPI to work 	 
Peltier_Mode		0x21	1		1		0x0		  0			 0x0		0x1		   0.		  0.	 Mode bit (0) normal operation, (1) programming mode. By setting this bit to 1 before bit 0 is set to 1, enable execution or programming enable instruction to uC. See http://www.atmel.com/Images/Atmel-8271-8-bit-AVRMicrocontroller-ATmega48A-48PA-88A-88PA-168A-168PA-328328P_datasheet.pdf Page 300-301 for details	 
Peltier_ResetBit	0x21	1		2		0x0		  0			 0x0		0x1		   0.		  0.	 Complement reset bit (invert) . In normal mode reset needs to be at high level (5V), so asserting this bit will assert reset (0V). And in programming mode reset needs to 0V (asserted), and this bit set to 1 will deassert reset (5V)	 
PeltierUnusedRegister0	0x21	5		3		0x0		  0			 0x0		0x0		   0.		  0.	 Unused	 
Peltier_ClockPeriod	0x21	8		8		0x0		  0			 0x0		0xFF	   256.		  0.	 Define clock period. Which will be equal Value * 256 (ns). For programming the blank device this value need to be set to 0x20 For normal operation in is function of many configuration parameters of actual code running on uC 	 
Unused_0x21		0x21	15		16		0x0		  0			 0x0		0x0		   0.		  0.	 Unused
Peltier_DoneBit		0x21	1		31		0x0		  0			 0x0		0x1		   0.		  0.	 Done bit. If mode bit (bit 1) set to 0 indicate completion of individual write operation, in programming mode (bit 1 set to 1), this bit indicate that programming to uC is enabled  and can be followed with uC programming commands 	 
Peltier_DataToUC	0x22	32		0		0x0		  0			 0x0		0xFFFFFFFF 0.		  0.	 32 bit value which need to be written to uC, Function of write to this register depend on normal or programming mode. Programming mode defined on page 301 of http://www.atmel.com/Images/Atmel-8271-8-bit-AVRMicrocontroller-ATmega48A-48PA-88A-88PA-168A-168PA-328328P_datasheet.pdf For normal mode details of protocol will be specified by uC firmware implementer.  	 
Peltier_DataCaptured	0x23	32		0		0x0		  0			 0x0		0xFFFFFFFF 0.		  0.	 Data captured from uC as response to communication to uC.Again, programming mode defined on  page 301 of  http://www.atmel.com/Images/Atmel-8271-8-bit-AVR-MicrocontrollerATmega48A-48PA-88A-88PA-168A-168PA-328-328P_datasheet.pdf Normal is up to implementation	 
# Flash memory write
Flash_ValueToWrite	0x24	16		0		0x0		  1			 0x0		0x0		   0.		  0.	 Value to be written to flash intermediate storage at location specified in bits 25-16	 
Flash_WriteAddress	0x24	10		16		0x0		  0			 0x0		0x3FF	   0.		  0.	 Address of flash intermediate command data storage for write.	 
Flash_WriteMSBAddress	0x24	1		26		0x0		  0			 0x0		0x1		   0.		  0.	 MSB Address , select flash 0(0), or 1(1)	 
Unused_0x24		0x24	4		27		0x0		  1			 0x0		0x0		   0.		  0.	 Unused
Flash_StartWrite		0x24	1		31		0x0		  0			 0x0		0x1		   0.		  0.	 Write to this bit (1) start operation of writing to flash command intermediate storage 	 
# Flash memory control
Flash_CommandSize		0x25	9		0		0x0		  0			 0x0		0x1FF	   0.		  0.	 Size of command in bytes to be played from intermediate command store	 
Flash_NotAsserted		0x25	1		9		0x0		  1			 0x0		0x0		   0.		  0.	 If set to 1, flash chip select will not be asserted16 
Unused_0x25_0		0x25	6		10		0x0		  1			 0x0		0x0		   0.		  0.	 
Flash_ReadSize		0x25	9		16		0x0		  0			 0x0		0x1FF	   0.		  0.	 Size of read operation in bytes to be to be stored into intermediate read store, 0x0  no read required 	 
Unused_0x25_1		0x25	5		25		0x0		  1			 0x0		0x0		   0.		  0.	 
Flash_Start0		0x25	1		30		0x0		  0			 0x0		0x1		   0.		  0.	 Write to this bit (1) start flash 0 command pre-stored in flash intermediate storage programmable in register 0x24. If command involve read operation data will be stored in intermediate storage accessible from register 0x26	 
Flash_Start1		0x25	1		31		0x0		  0			 0x0		0x1		   0.		  0.	 Write to this bit (1) start flash 1 command pre-stored in flash intermediate storage programmable in register 0x24. If command involve read operation data will be stored in intermediate storage accessible from register 0x26  	 
# Flash memory read
Flash_ReadValue			0x26	16		0		0x0		  1			 0x0		0x0		   0.		  0.	 Value read from flash intermediate storge at location specified in bits 25-16.
Flash_ReadAddress		0x26	10		16		0x0		  0			 0x0		0x3FF	   0.		  0.	 Address of flash intermediate data storage to read. 
Flash_ReadMSBAddress	0x26	1		26		0x0		  0			 0x0		0x1		   0.		  0.	 MSB Address , select flash 0(0), or 1(1)
Unused_0x26		0x26	3		27		0x0		  1			 0x0		0x0		   0.		  0.	 Unused
Flash_DoneBit		0x26	1		30		0x1		  0			 0x0		0x1		   0.		  0.	 Done bit, indicate that flash command is completed
Flash_Start		0x26	1		31		0x0		  0			 0x0		0x1		   0.		  0.	 Write to this bit (1) start operation of reading which can be completed on follow up read 
# Zero-suppression control register
Zero_Threshold			0x27	12		0		0x0		  0			 0x0		0xFF	   0.		  0.	 Set threshold value to compare. Discard if all values under threshold.
Zero_OverflowValue		0x27	12		12		0x0		  0			 0x0		0xFF	   0.		  0.	 Set overflow value to properly handle overflow
Unused_0x27		0x27	6		24		0x0		  0			 0x0		0x3F	   0.		  0.	 Unused
Zero_Test		0x27	1		30		0x0		  0			 0x0		0x1		   0.		  0.	 Test zero-suppression reporting. Configure system return only enabled channels regarding zero-suppression logic  
Zero_Enable		0x27	1		31		0x0		  0			 0x0		0x1		   0.		  0.	 Enable zero suppression algorithm. This algorithm discard all suppressed channels  
# Monitor results register
Monitor_OutputData		0x28	16		0		0x0		  1			 0x0		0x0		   0.		  0.	 Output data for FPGA monitoring  interface, DO on page 14 of http://www.xilinx.com/support/documentation/user_guides/ug480_7Series_XADC.pdf 
Monitor_Address			0x28	7		16		0x0		  1			 0x0		0x0		   0.		  0.	 Data address for FPGA monitoring  interface, DADDR on page 14 of http://www.xilinx.com/support/documentation/user_guides/ug480_7Series_XADC.pdf 
Unused_0x28			0x28	8		23		0x0		  1			 0x0		0x0		   0.		  0.	 Unused	
Monitor_Always1			0x28	1		31		0x0		  1			 0x0		0x0		   0.		  0.	 Always 1
# MAX11616 ADC 0 Data
MAX11616_ADC0_HVCurrent	0x29	12		0		0x0		  1			 0x0		0x0		   0.1		  0.	 MAX11616 ADC, HV current ,conversion is I,mA = value/10
Unused_0x29_0		0x29	3		12		0x0		  1			 0x0		0x0		   0.		  0.	 Unused
MAX11616_ADC0_ValidBit0	0x29	1		15		0x0		  1			 0x0		0x0		   0	      0.	 ADC, Valid data bit,  1 indicate data valid, 0  is in conversion.
MAX11616_ADC0_HVVoltage	0x29	12		16		0x0		  1			 0x0		0x0		   0.021		  0.	 MAX11616 ADC, HV voltage ,conversion is V,V = 21*value/1000
Unused_0x29_1		0x29	3		28		0x0		  1			 0x0		0x0		   0.		  0.	 Unused
MAX11616_ADC0_ValidBit1	0x29	1		31		0x0		  1			 0x0		0x0		   0.		  0.	 ADC, Valid data bit,  1 indicate data valid, 0  is in conversion.
# The following registers are the MAX11616 ADC that are not used in T7
Unused_0x2a		0x2a 	32	0			0x0 		0			0x0 		0x0 		   0. 		0.  Unused ADC
Unused_0x2b		0x2b 	32	0			0x0 		0			0x0 		0x0 		   0. 		0.  Unused ADC
Unused_0x2c		0x2c 	32	0			0x0 		0			0x0 		0x0 		   0. 		0.  Unused ADC
Unused_0x2d		0x2d 	32	0			0x0 		0			0x0 		0x0 		   0. 		0.  Unused ADC
Unused_0x2e		0x2e 	32	0			0x0 		0			0x0 		0x0 		   0. 		0.  Unused ADC
Unused_0x2f		0x2f 	32	0			0x0 		0			0x0 		0x0 		   0. 		0.  Unused ADC
# Vped DAC control
Vped_value				0x30	12		0		0x0		  0			 0x0		0xFFF	   0.85499 0.	 VPED value from 0 to 2.5V (Max value enforced in hardware is 0xB6C ~2.5V) 
Unused_0x30				0x30	20		12		0x0		  0			 0x0		0x0		   0.		  0.	 Unused
# TACK simulator LSW
TACK_Command0			0x31	32		0		0x0		  0			 0x0		0xFFFFFFFF 0.		  0.	 Bits 0 to 31 of TACK command (see section 8), Write to register 0x33 initiate this command application 
# TACK simulator MSW	
TACK_Command1			0x32	32		0		0x0		  0			 0x0		0xFFFFFFFF 0.		  0.	 Bits 32 to 63 of TACK command (see section 8), Write to register 0x33 initiate this command application 
# TACK simulator Special word
TACK_EnableTrigger		0x33	18		0		0x0		  0			 0x0		0xFFFFFFFF 0.		  0.	 Enable trigger input. Bits assigned as followed: 0 –trigger bit 0, 1 –trigger bit 1,  ...,  15  – trigger bit 15 ,16 – external hardware trigger, 17 – software trigger	 
TACK_TriggerType		0x33	2		18		0x0		  0			 0x0		0x3 	   0.		  0.	 Trigger type: for trigger mode 00: 00 – TACK with number of buffers and trigger delay for set 0,01 - TACK with number of buffers and trigger delay for set 1, 10 – software trigger, 11 - unused	; for trigger mode 01: 00 – Initial sync command, can be done only once for proper, operation, can be reassured after stop sync command (trigger type 10), 01 – Re-sync command, passive command, checked on cameramodule do detect if any difference between time base on camera module and tester board, 10 – stop sync command, after stop sync command, to operate triggering on camera module sync command need to be reissued, 11 - unused
TACK_TriggerMode		0x33	2		20		0x0		  0			 0x0		0x3 	   0.     	  0.	 Trigger mode: 00 – regular trigger, 01 – sync related operation, 10 - unused, 11 - unused
TACK_TriggerDead		0x33	7		22		0x0		  0			 0x0		0x7F 	   2048			rigger dead time, after trigger detected and processed module will ignore the next trigger for number of ns specified in these bits. Asserted deadtime = Value * 256*8ns.
TACK_Resync				0x33	1		29		0x0		  0			 0x0		0x1 	   0.		  0.	 RE-sync trigger, take current time on tester board and send to camera module. Correct Trigger mode need to be used 
TACK_Parity				0x33	1		30		0x0		  0			 0x0		0x1 	   0.		  0.	 Parity of TACK, 0- even parity, 1 – odd parity, TBD 
TACK_Set				0x33	1		31		0x0		  0			 0x0		0x1 	   0.		  0.	 Software trigger, if software trigger enable, it is treated as random trigger, otherwise, it sent command specified in TACK register and TACK mode registers
# MAX1230 ADC 0 Data
ADC0_Temperature0		0x34	12		0		0x0		  1			 0x0		0x0 	   0.125	  0.	 ADC , Temperature measured by ADC 0,conversion is T,C = value*0.125, C 
Unused_0x34_0			0x34	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC0_ValidBit0			0x34	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC0_Temperature1		0x34	12		16		0x0		  1			 0x0		0x0 	   0.125	  0.	 ADC , Temperature measured by ADC 2, conversion is T,C = value*0.125, C 	 
Unused_0x34_1			0x34	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC0_ValidBit1			0x34	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
# MAX1230 ADC 1 Data
ADC1_Current0			0x35	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 0 channel 0 current(0), conversion is I = value/2, uA 
Unused_0x35_0			0x35	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC1_ValidBit0			0x35	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC1_Current1			0x35	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 2 channel 0 current(32), conversion is I = value/2, uA 	 
Unused_0x35_1			0x35	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC1_ValidBit1			0x35	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 	 
# MAX1230 ADC 2 Data
ADC2_Current0			0x36	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 0 channel 1 current(1), conversion is I = value/2, uA 
Unused_0x36_0			0x36	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC2_ValidBit0			0x36	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC2_Current1			0x36	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 2 channel 1 current(33), conversion is I = value/2, uA 	 
Unused_0x36_1			0x36	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC2_ValidBit1			0x36	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 	 
# MAX1230 ADC 3 Data
ADC3_Current0			0x37	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 0 channel 2 current(2), conversion is I = value/2, uA 
Unused_0x37_0			0x37	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC3_ValidBit0			0x37	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC3_Current1			0x37	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 2 channel 2 current(34), conversion is I = value/2, uA 	 
Unused_0x37_1			0x37	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC3_ValidBit1			0x37	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 	 
# MAX1230 ADC 4 Data
ADC4_Current0			0x38	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 0 channel 3 current(3), conversion is I = value/2, uA 
Unused_0x38_0			0x38	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC4_ValidBit0			0x38	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC4_Current1			0x38	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 2 channel 3 current(35), conversion is I = value/2, uA 	 
Unused_0x38_1			0x38	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC4_ValidBit1			0x38	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 	 
# MAX1230 ADC 5 Data
ADC5_Current0			0x39	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 0 channel 4 current(4), conversion is I = value/2, uA 
Unused_0x39_0			0x39	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC5_ValidBit0			0x39	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC5_Current1			0x39	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 2 channel 4 current(36), conversion is I = value/2, uA 	 
Unused_0x39_1			0x39	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC5_ValidBit1			0x39	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 	 
# MAX1230 ADC 6 Data
ADC6_Current0			0x3a	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 0 channel 5 current(5), conversion is I = value/2, uA 
Unused_0x3a_0			0x3a	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC6_ValidBit0			0x3a	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC6_Current1			0x3a	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 2 channel 5 current(37), conversion is I = value/2, uA 	 
Unused_0x3a_1			0x3a	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC6_ValidBit1			0x3a	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 	 
# MAX1230 ADC 7 Data
ADC7_Current0			0x3b	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 0 channel 6 current(6), conversion is I = value/2, uA 
Unused_0x3b_0			0x3b	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC7_ValidBit0			0x3b	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC7_Current1			0x3b	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 2 channel 6 current(38), conversion is I = value/2, uA 	 
Unused_0x3b_1			0x3b	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC7_ValidBit1			0x3b	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 	 
# MAX1230 ADC 8 Data
ADC8_Current0			0x3c	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 0 channel 7 current(7), conversion is I = value/2, uA 
Unused_0x3c_0			0x3c	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC8_ValidBit0			0x3c	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC8_Current1			0x3c	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 2 channel 7 current(39), conversion is I = value/2, uA 	 
Unused_0x3c_1			0x3c	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC8_ValidBit1			0x3c	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 	 
# MAX1230 ADC 9 Data
ADC9_Current0			0x3d	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 0 channel 8 current(8), conversion is I = value/2, uA 
Unused_0x3d_0			0x3d	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC9_ValidBit0			0x3d	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC9_Current1			0x3d	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 2 channel 8 current(40), conversion is I = value/2, uA 	 
Unused_0x3d_1			0x3d	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC9_ValidBit1			0x3d	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 	 
# MAX1230 ADC 10 Data
ADC10_Current0			0x3e	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 0 channel 9 current(9), conversion is I = value/2, uA 
Unused_0x3e_0			0x3e	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC10_ValidBit0			0x3e	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC10_Current1			0x3e	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 2 channel 9 current(41), conversion is I = value/2, uA 	 
Unused_0x3e_1			0x3e	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC10_ValidBit1			0x3e	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 	 
# MAX1230 ADC 11 Data
ADC11_Current0			0x3f	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 0 channel 10 current(10), conversion is I = value/2, uA 
Unused_0x3f_0			0x3f	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC11_ValidBit0			0x3f	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC11_Current1			0x3f	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 2 channel 10 current(42), conversion is I = value/2, uA 	 
Unused_0x3f_1			0x3f	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC11_ValidBit1			0x3f	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion.
# MAX1230 ADC 12 Data
ADC12_Current0			0x40	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 0 channel 11 current(11), conversion is I = value/2, uA 
Unused_0x40_0			0x40	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC12_ValidBit0			0x40	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC12_Current1			0x40	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 2 channel 11 current(43), conversion is I = value/2, uA 	 
Unused_0x40_1			0x40	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC12_ValidBit1			0x40	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 	 
# MAX1230 ADC 13 Data
ADC13_Current0			0x41	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 0 channel 12 current(12), conversion is I = value/2, uA 
Unused_0x41_0			0x41	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC13_ValidBit0			0x41	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC13_Current1			0x41	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 2 channel 12 current(44), conversion is I = value/2, uA 	 
Unused_0x41_1			0x41	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC13_ValidBit1			0x41	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 	 
# MAX1230 ADC 14 Data
ADC14_Current0			0x42	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 0 channel 13 current(13), conversion is I = value/2, uA 
Unused_0x42_0			0x42	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC14_ValidBit0			0x42	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC14_Current1			0x42	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 2 channel 13 current(45), conversion is I = value/2, uA 	 
Unused_0x42_1			0x42	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC14_ValidBit1			0x42	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 	 
# MAX1230 ADC 15 Data
ADC15_Current0			0x43	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 0 channel 14 current(14), conversion is I = value/2, uA 
Unused_0x43_0			0x43	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC15_ValidBit0			0x43	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC15_Current1			0x43	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 2 channel 14 current(46), conversion is I = value/2, uA 	 
Unused_0x43_1			0x43	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC15_ValidBit1			0x43	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 	 
# MAX1230 ADC 16 Data
ADC16_Current0			0x44	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 0 channel 15 current(15), conversion is I = value/2, uA 
Unused_0x44_0			0x44	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC16_ValidBit0			0x44	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC16_Current1			0x44	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 2 channel 15 current(47), conversion is I = value/2, uA 	 
Unused_0x44_1			0x44	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC16_ValidBit1			0x44	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 	 
# MAX1230 ADC 17 Data
ADC17_Temperature0		0x45	12		0		0x0		  1			 0x0		0x0 	   0.125	  0.	 ADC , Temperature measured by ADC 1,conversion is T,C = value*0.125, C 
Unused_0x45_0			0x45	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC17_ValidBit0			0x45	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC17_Temperature1		0x45	12		16		0x0		  1			 0x0		0x0 	   0.125	  0.	 ADC , Temperature measured by ADC 3, conversion is T,C = value*0.125, C 	 
Unused_0x45_1			0x45	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC17_ValidBit1			0x45	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
# MAX1230 ADC 18 Data
ADC18_Current0			0x46	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 1 channel 0 current(16), conversion is I = value/2, uA 
Unused_0x46_0			0x46	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC18_ValidBit0			0x46	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC18_Current1			0x46	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 3 channel 0 current(48), conversion is I = value/2, uA 	 
Unused_0x46_1			0x46	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC18_ValidBit1			0x46	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
# MAX1230 ADC 19 Data
ADC19_Current0			0x47	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 1 channel 1 current(17), conversion is I = value/2, uA 
Unused_0x47_0			0x47	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC19_ValidBit0			0x47	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC19_Current1			0x47	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 3 channel 1 current(49), conversion is I = value/2, uA 	 
Unused_0x47_1			0x47	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC19_ValidBit1			0x47	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
# MAX1230 ADC 20 Data
ADC20_Current0			0x48	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 1 channel 2 current(18), conversion is I = value/2, uA 
Unused_0x48_0			0x48	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC20_ValidBit0			0x48	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC20_Current1			0x48	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 3 channel 2 current(50), conversion is I = value/2, uA 	 
Unused_0x48_1			0x48	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC20_ValidBit1			0x48	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
# MAX1230 ADC 21 Data
ADC21_Current0			0x49	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 1 channel 3 current(19), conversion is I = value/2, uA 
Unused_0x49_0			0x49	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC21_ValidBit0			0x49	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC21_Current1			0x49	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 3 channel 3 current(51), conversion is I = value/2, uA 	 
Unused_0x49_1			0x49	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC21_ValidBit1			0x49	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
# MAX1230 ADC 22 Data
ADC22_Current0			0x4a	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 1 channel 4 current(20), conversion is I = value/2, uA 
Unused_0x4a_0			0x4a	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC22_ValidBit0			0x4a	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC22_Current1			0x4a	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 3 channel 4 current(52), conversion is I = value/2, uA 	 
Unused_0x4a_1			0x4a	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC22_ValidBit1			0x4a	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
# MAX1230 ADC 23 Data
ADC23_Current0			0x4b	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 1 channel 5 current(21), conversion is I = value/2, uA 
Unused_0x4b_0			0x4b	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC23_ValidBit0			0x4b	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC23_Current1			0x4b	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 3 channel 5 current(53), conversion is I = value/2, uA 	 
Unused_0x4b_1			0x4b	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC23_ValidBit1			0x4b	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
# MAX1230 ADC 24 Data
ADC24_Current0			0x4c	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 1 channel 6 current(22), conversion is I = value/2, uA 
Unused_0x4c_0			0x4c	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC24_ValidBit0			0x4c	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC24_Current1			0x4c	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 3 channel 6 current(54), conversion is I = value/2, uA 	 
Unused_0x4c_1			0x4c	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC24_ValidBit1			0x4c	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
# MAX1230 ADC 25 Data
ADC25_Current0			0x4d	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 1 channel 7 current(23), conversion is I = value/2, uA 
Unused_0x4d_0			0x4d	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC25_ValidBit0			0x4d	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC25_Current1			0x4d	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 3 channel 7 current(55), conversion is I = value/2, uA 	 
Unused_0x4d_1			0x4d	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC25_ValidBit1			0x4d	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
# MAX1230 ADC 26 Data
ADC26_Current0			0x4e	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 1 channel 8 current(24), conversion is I = value/2, uA 
Unused_0x4e_0			0x4e	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC26_ValidBit0			0x4e	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC26_Current1			0x4e	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 3 channel 8 current(56), conversion is I = value/2, uA 	 
Unused_0x4e_1			0x4e	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC26_ValidBit1			0x4e	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
# MAX1230 ADC 27 Data
ADC27_Current0			0x4f	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 1 channel 9 current(25), conversion is I = value/2, uA 
Unused_0x4f_0			0x4f	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC27_ValidBit0			0x4f	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC27_Current1			0x4f	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 3 channel 9 current(57), conversion is I = value/2, uA 	 
Unused_0x4f_1			0x4f	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC27_ValidBit1			0x4f	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
# MAX1230 ADC 28 Data
ADC28_Current0			0x50	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 1 channel 10 current(26), conversion is I = value/2, uA 
Unused_0x50_0			0x50	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC28_ValidBit0			0x50	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC28_Current1			0x50	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 3 channel 10 current(58), conversion is I = value/2, uA 	 
Unused_0x50_1			0x50	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC28_ValidBit1			0x50	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
# MAX1230 ADC 29 Data
ADC29_Current0			0x51	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 1 channel 11 current(27), conversion is I = value/2, uA 
Unused_0x51_0			0x51	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC29_ValidBit0			0x51	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC29_Current1			0x51	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 3 channel 11 current(59), conversion is I = value/2, uA 	 
Unused_0x51_1			0x51	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC29_ValidBit1			0x51	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion5
# MAX1230 ADC 30 Data
ADC30_Current0			0x52	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 1 channel 12 current(28), conversion is I = value/2, uA 
Unused_0x52_0			0x52	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC30_ValidBit0			0x52	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC30_Current1			0x52	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 3 channel 12 current(60), conversion is I = value/2, uA 	 
Unused_0x52_1			0x52	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC30_ValidBit1			0x52	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion5
# MAX1230 ADC 31 Data
ADC31_Current0			0x53	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 1 channel 13 current(29), conversion is I = value/2, uA 
Unused_0x53_0			0x53	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC31_ValidBit0			0x53	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC31_Current1			0x53	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 3 channel 13 current(61), conversion is I = value/2, uA 	 
Unused_0x53_1			0x53	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC31_ValidBit1			0x53	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion5
# MAX1230 ADC 32 Data
ADC32_Current0			0x54	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 1 channel 14 current(30), conversion is I = value/2, uA 
Unused_0x54_0			0x54	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC32_ValidBit0			0x54	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC32_Current1			0x54	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 3 channel 14 current(62), conversion is I = value/2, uA 	 
Unused_0x54_1			0x54	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC32_ValidBit1			0x54	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion5
# MAX1230 ADC 33 Data
ADC33_Current0			0x55	12		0		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 1 channel 15 current(31), conversion is I = value/2, uA 
Unused_0x55_0			0x55	3		12		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused
ADC33_ValidBit0			0x55	1		15		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion. 
ADC33_Current1			0x55	12		16		0x0		  1			 0x0		0x0 	   0.5		  0.	 ASIC 3 channel 15 current(63), conversion is I = value/2, uA 	 
Unused_0x55_1			0x55	3		28		0x0		  1			 0x0		0x0 	   0.		  0.	 Unused	 
ADC33_ValidBit1			0x55	1		31		0x0		  1			 0x0		0x0 	   0.		  0.	 ADC , Valid data bit, if bit 0 of register 14 set 0, 1 indicate data valid, 0 – is in conversion5
# Trigger efficiency control 0 
TriggerEff_Duration		0x56	31		0		0x0		  0			 0x0		0x7FFFFFFF 8.		  0.	 Specify duration of trigger statistic collection in 8ns. So, full value is ~8.5 seconds 
TriggerEff_DoneBit		0x56	1		31		0x1		  0			 0x0		0x1 	   0.		  0.	 Indicate completion of counting 
# Trigger efficiency control 1
TriggerEff_Enable		0x57	16		0		0x0		  0			 0x0		0xFFFF	   0.		  0.     Enable for trigger inputs into efficiency counters in register 0x4b. One bit per trigger input	 
Unused_0x57			0x57	16		16		0x0		  1			 0x0		0x0		   0.		  0.     Unused 
# Trigger input counter
TriggInputCounter		0x58	31		0		0x0		  0			 0x0		0x7FFFFFFF 8.		  0.	 Number of trigger low to high transitions counted  
TriggInputCounterDone	0x58	1		31		0x1		  0			 0x0		0x1		   8.		  0.	 Indicate completion of counting
# Trigger efficiency counter
TriggEffCounter			0x59	31		0		0x0		  0			 0x0		0x7FFFFFFF 8.		  0.	 Number of trigger low to high transitions counted 
TriggEffCounterDone		0x59	1		31		0x1		  0			 0x0		0x1		   8.		  0.	 Indicate completion of counting
# Software reset
SoftwareReset			0x5a	32		0		0x0		  2			 0x0		0xFFFFFFFF 0.		  0.	 Writing value of 0xBECEDACE will start reset of FPGA logic, but keep values programmed into register. Also, write to this register does not generate command response due to transmitter logic reset as well
# Channel enable 0		
EnableChannelsASIC0		0x5b	16		0		0x0 		  0			0x0		0xFFFF	   0.		0.	Enable channels for readout on ASIC 0, bit-mask	
EnableChannelsASIC1		0x5b	16		16		0x0 		  0			0x0		0xFFFF	   0.		0.	Enable channels for readout on ASIC 1, bit-mask	
# Channel enable 1
EnableChannelsASIC2		0x5c	16		0		0x0 		  0			0x0		0xFFFF	   0.		0.	Enable channels for readout on ASIC 2, bit-mask	
EnableChannelsASIC3		0x5c	16		16		0x0 		  0			0x0		0xFFFF	   0.		0.	Enable channels for readout on ASIC 3, bit-mask	
# Trigger statistic 1
TriggStatCount_All		0x5d	16		0		0x0		  0			 0x0		0xFFFF	   0.		  0.     Count trigger low to high transitions on all incoming triggers (16 from fourTarget ASICs, 1 software trigger(bit 31 of register 0x1a), and 1 external hardware trigger). Trigger transition observed on same clock transition counted as one trigger. Counter is reset by writing value of 1 into bit 30 of register 0x1a  
TriggStatCount_Enabled	0x5d	16		16		0x0		  0			 0x0		0xFFFF	   0.		  0. 	 Count trigger low to high transitions on all enabled for counting (bits 17-0 of register 0x1a) incoming triggers (16 from four Target ASICs, 1 software trigger(bit 31 of register 0x1a), and 1 external hardware trigger). Trigger transition observed on same clock transition counted as one trigger. Counter is reset by writing value of 1 into bit 30 of register 0x1a    
# Special feature (expert usage only) 
Unused_0x5e_0			0x5e	6		0		0x0		  0			 0x0		0x0	   	   0.		  0.	 Unused , TBD  
ExtTriggerDirection		0x5e	1		6		0x1		  0			 0x0		0x1	       0.		  0. 	 To control direction of External Trigger IO, 0 – output (sync with sampling), 1 - input     
SpecialTriggerMode		0x5e	1		7		0x0		  0			 0x0		0x1	       0.		  0.	 Special trigger mode. When set to 1 enable J5 output generate pulse on every sampling buffer turn for 10 event and stop. To reactivate need to bring it back to 0, if 0 - trigger sync command generated ~ at 1kHz     
SerialDataDelay			0x5e	7		8		0x0		  0			 0x0		0x7F       0.		  0.	 Adjust event serial data input delay to make sure all channels properly clock input data      
ReadSamplesDirection		0x5e	1		15		0x0		  0			 0x0		0x1	       0.		  0.	 To study drooping effect of sample 31(32nd) we can read samples in increasing (0) or decreasing (1) order.      
Unused_0x5e_1			0x5e	16		16		0x0		  0			 0x0		0x0	       0.		  0.  	 Unused , TBD    
# Dead-time control
DelayAfterReadout		0x5f	14		0		0x0		  0			 0x0		0x3FFF     8.		  0.	 Delay after readout start to assert trigger deadtime, in 8ns steps     
DeadTimeUnused0			0x5f	1		14		0x0		  0			 0x0		0x1        0.		  0. 	 Unused
EnableDeadTimeLogic		0x5f	1		15		0x0		  0			 0x0		0x1        0.		  0.	 Enable deadtime logic 
DurationofDeadtime		0x5f	16		16		0x0		  0			 0x0		0xFFFF     8.		  0. 	 Duration of trigger deadtime, in 8ns steps 
# Write Target
WriteTargetValue		0x60	12		0		0x0		  1			 0x0		0xFFF      0.		  0.	 Target register value to write. See Target 7 documentation for specific registers and bit allocation. Set to read only so it is skipped in initialisation, interface is through WriteASICSetting
WriteTargetAdress		0x60	7		12		0x0		  1			 0x0		0x7F       0.		  0.	 Target register address to write. See Target 7 documentation for specific register address map. Set to read only so it is skipped in initialisation, interface is through WriteASICSetting
EnableLatching			0x60	1		19		0x0		  1			 0x0		0x1        0.		  0.	 Define if data latching on Target is required. 0 – latching is required, 1 – no latching. Set to read only so it is skipped in initialisation, interface is through WriteASICSetting
ReadBackImmediately		0x60	1		20		0x0		  1			 0x0		0x1        0.		  0.	 If bit 19 is set (1) read back followed immediately after write. Otherwise, read of previously written register. Set to read only so it is skipped in initialisation, interface is through WriteASICSetting
EnableWriteASIC0		0x60	1		21		0x1		  1			 0x0		0x1        0.		  0.	 Enable (1) write/read operation to ASIC 0. Set to read only so it is skipped in initialisation, interface is through WriteASICSetting
EnableWriteASIC1		0x60	1		22		0x1		  1			 0x0		0x1        0.		  0.	 Enable (1) write/read operation to ASIC 1. Set to read only so it is skipped in initialisation, interface is through WriteASICSetting
EnableWriteASIC2		0x60	1		23		0x1		  1			 0x0		0x1        0.		  0. 	 Enable (1) write/read operation to ASIC 2. Set to read only so it is skipped in initialisation, interface is through WriteASICSetting
EnableWriteASIC3		0x60	1		24		0x1		  1			 0x0		0x1        0.		  0.	 Enable (1) write/read operation to ASIC 3. Set to read only so it is skipped in initialisation, interface is through WriteASICSetting
Unused_0x60			0x60	7		25		0x1		  1			 0x0		0x0        0.		  0.     Unused
# Read Target 0
ReadTargetASIC0			0x61	12		0		0x0		  1			 0x0		0x0        0.		  0.	 Read back value from ASIC 0. Updated after Target ASIC operation enabled in register 0x40(bit 20). If bit 19 is set (1) read back followed immediately after write. Otherwise, read of previously written register 
Unused_0x61_0			0x61	4		12		0x0		  0			 0x0		0x0        0.		  0. 	 Unused
ReadTargetASIC1			0x61	12		16		0x0		  1			 0x0		0x0        0.		  0.	 Read back value from ASIC 0. Updated after Target ASIC operation enabled in register 0x40(bit 20). If bit 19 is set (1) read back followed immediately after write. Otherwise, read of previously written register 
Unused_0x61_1			0x61	4		28		0x0		  0			 0x0		0x0        0.		  0.. 	 Unused 
# Read Target 1
ReadTargetASIC2			0x62	12		0		0x0		  1			 0x0		0x0        0.		  0.	 Read back value from ASIC 0. Updated after Target ASIC operation enabled in register 0x40(bit 20). If bit 19 is set (1) read back followed immediately after write. Otherwise, read of previously written register 
Unused_0x62_0			0x62	4		12		0x0		  0			 0x0		0x0        0.		  0.. 	 Unused 
ReadTARGETASIC3			0x62	12		16		0x0		  1			 0x0		0x0        0.		  0.	 Read back value from ASIC 0. Updated after Target ASIC operation enabled in register 0x40(bit 20). If bit 19 is set (1) read back followed immediately after write. Otherwise, read of previously written register 
Unused_0x62_1			0x62	4		28		0x0		  0			 0x0		0x0        0.		  0.. 	 Unused
# Spare Registers
Unused_0x63				0x63	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x64				0x64	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x65				0x65	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x66				0x66	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x67				0x67	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x68				0x68	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x69				0x69	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x6a				0x6a	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x6b				0x6b	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x6c				0x6c	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x6d				0x6d	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x6e				0x6e	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x6f				0x6f	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
DataSendingDelay			0x70	13		0		0x0		  0			 0x0		0x1FFF		   0.		  0.	 Event Delay in 128 ns steps
EnableCommsClockFromARP  		0x70    1       	13       	0x0     	  0           		 0x0        	0x1        	   0.         	  0.     If set to 0: recover phase of comms clock from ARP messages; if set to 1: manually set phase in bit 14 (although 0 is selected, manually setting phase might be required due to buggy implementation)
PhaseOfCommsClock	      		0x70	1	      	14	       	0x0	  	  0	     		 0x0	    	0x1		   0.	      	  0.     Select the phase of the clock which determines the 8 ns / 16 ns edge for the ethernet responses
Unused_0x70				0x70	17		15		0x0		  1			 0x0		0x0		   0.		  0.	 Spare bits of register 0x70
Unused_0x71				0x71	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x72				0x72	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x73				0x73	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x74				0x74	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x75				0x75	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x76				0x76	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x77				0x77	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x78				0x78	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x79				0x79	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x7a				0x7a	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x7b				0x7b	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x7c				0x7c	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x7d				0x7d	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x7e				0x7e	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
Unused_0x7f				0x7f	32		0		0x0		  1			 0x0		0x0		   0.		  0.	 Spare Register
# Set Data and SlowControl Ports
SetDataPort				0x80	16 		0	    0x0		  0			 0x0		0xFFFF	   0.		  0.	Specify Data Port, if 0 --> behaviour like for firmware version 0xFEDA0003, only change from 0 when you really want to setup an specific data port for this module. When 0, TargetDriver will set data port 
SetSlowControlPort		0x80	16 		16		0x0		  0			 0x0		0xFFFF	   0.		  0. 	Specify Slow Control Port, if 0 --> behaviour like for firmware version 0xFEDA0003, only change from 0 when you really want to setup an specific slow port for this module. When 0, TargetDriver will set slow port 
